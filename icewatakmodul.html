<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ice Climber - Dev Pemain</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { background-color: #1a1a1a; color: #f0f0f0; display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; font-family: 'Press Start 2P', cursive; }
        .main-container { display: flex; align-items: center; gap: 30px; }
        .game-column { display: flex; flex-direction: column; align-items: center; }
        .version-info-dev { font-size: 0.7rem; color: #888; margin-top: -15px; margin-bottom: 15px; }
        .game-wrapper { position: relative; }
        #game-canvas { background-color: #000; border: 4px solid #555; border-radius: 10px; display: block; }
        
        #on-screen-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: auto;
        }
        .d-pad { position: relative; width: 120px; height: 120px; }
        .d-pad-btn {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.5rem;
            -webkit-user-select: none; user-select: none;
            transition: background-color: 0.1s;
        }
        .d-pad .up { top: 0; left: 40px; }
        .d-pad .left { top: 40px; left: 0; }
        .d-pad .right { top: 40px; left: 80px; }
        .d-pad .down { top: 80px; left: 40px; }

        .action-buttons { display: flex; gap: 15px; }
        .action-btn {
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.7);
             -webkit-user-select: none; user-select: none;
             transition: background-color 0.1s;
        }
        .d-pad-btn.pressed, .action-btn.pressed {
            background-color: rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="game-column">
            <h1>Ice Climber (Dev Pemain)</h1>
            <p class="version-info-dev">v-dev-player-1.5</p>
            <div class="game-wrapper">
                <canvas id="game-canvas" width="400" height="600"></canvas>
                <div id="on-screen-controls">
                    <div class="d-pad">
                        <div id="btn-up" class="d-pad-btn up">&#9652;</div>
                        <div id="btn-left" class="d-pad-btn left">&#9664;</div>
                        <div id="btn-right" class="d-pad-btn right">&#9654;</div>
                        <div id="btn-down" class="d-pad-btn down">&#9662;</div>
                    </div>
                    <div class="action-buttons">
                        <div id="btn-b" class="action-btn">B</div>
                        <div id="btn-a" class="action-btn">A</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const Game = {
            // --- CORE MODULE: Main game loop and state management ---
            Core: {
                animationFrameId: null,
                init: function() {
                    Game.Controls.setupEventListeners();
                    Game.Level.generatePlatforms();
                    Game.Enemies.generateEnemies();
                    this.resetStage();
                    this.gameLoop();
                },
                gameLoop: function() {
                    Game.Core.update();
                    Game.Graphics.draw();
                    Game.Core.animationFrameId = requestAnimationFrame(Game.Core.gameLoop);
                },
                update: function() {
                    Game.State.globalAnimationTick++;
                    
                    if (Game.State.player.hitTimer > 0) {
                        Game.State.player.hitTimer--;
                    } else {
                        Game.State.player.isHit = false;
                    }

                    if (Game.State.player.powerUpCooldown > 0) {
                        Game.State.player.powerUpCooldown--;
                    }

                    Game.Player.handlePlayerInput();
                    Game.Player.updateActions();
                    Game.Player.updatePlayerPosition();
                    Game.Player.checkPlayerCollisions();
                    Game.Enemies.updateEnemies();
                    Game.Enemies.updateProjectiles();
                },
                resetStage: function() {
                    const player = Game.State.player;
                    const floor = Game.State.platforms[0];
                    player.x = 20;
                    player.y = floor.y - player.height;
                    player.dx = 0;
                    player.dy = 0;
                    player.onGround = true;
                    player.isCrouching = false;
                    player.platformToDropThrough = null;
                    player.powerUp = null;
                    player.powerUpCooldown = 0;
                    Game.Enemies.generateEnemies();
                    Game.Level.generatePowerUps();
                }
            },

            // --- CONSTANTS MODULE ---
            Constants: {
                GRAVITY: 0.5,
                JUMP_POWER: -12,
                PLATFORM_HEIGHT: 15,
                VERTICAL_GAP: 120,
                FRICTION: 0.97,
            },

            // --- STATE MODULE ---
            State: {
                canvas: document.getElementById('game-canvas'),
                ctx: document.getElementById('game-canvas').getContext('2d'),
                globalAnimationTick: 0,
                player: { 
                    width: 30, height: 30, x: 20, y: 530, dx: 0, dy: 0, 
                    onGround: true, standingOnPlatform: null,
                    isCrouching: false,
                    canDropDown: true,
                    platformToDropThrough: null,
                    isHit: false, 
                    hitTimer: 0,
                    powerUp: null,
                    powerUpCooldown: 0,
                    direction: 'right',
                    isAttacking: false,
                    attackTimer: 0,
                    isBlocking: false,
                },
                platforms: [],
                enemies: [],
                projectiles: [],
                powerUps: [],
                playerSpeed: 3,
                canJump: true,
                jumpDelay: 500,
                enemySpeed: 1,
            },
            
            // --- LEVEL MODULE (Simplified) ---
            Level: {
                generatePlatforms: function() {
                    const C = Game.Constants;
                    Game.State.platforms = [
                        { x: 0, y: 560, width: 400, height: 40, slippery: false },
                        { x: 150, y: 460, width: 200, height: C.PLATFORM_HEIGHT, slippery: true },
                        { x: 50, y: 360, width: 150, height: C.PLATFORM_HEIGHT, slippery: false },
                    ];
                },
                generatePowerUps: function() {
                    const floor = Game.State.platforms[0];
                    Game.State.powerUps = [
                        { type: 'HAMMER', x: 200, y: floor.y - 25, width: 25, height: 25 },
                        { type: 'SHIELD', x: 250, y: floor.y - 25, width: 25, height: 25 },
                    ];
                }
            },

            // --- PLAYER MODULE ---
            Player: {
                handlePlayerInput: function() {
                    const player = Game.State.player;
                    const keys = Game.Controls.keys;
                    
                    if (!player.isAttacking) { // Prevent movement while attacking
                        player.isCrouching = (keys.down && player.onGround);

                        const onSlipperyPlatform = player.onGround && player.standingOnPlatform && player.standingOnPlatform.slippery;

                        if (keys.left) {
                            player.direction = 'left';
                            if (onSlipperyPlatform) {
                                if (player.dx > 0) player.dx *= Game.Constants.FRICTION;
                                player.dx = Math.max(player.dx - 0.4, -Game.State.playerSpeed);
                            } else {
                                player.dx = -Game.State.playerSpeed;
                            }
                        } else if (keys.right) {
                            player.direction = 'right';
                            if (onSlipperyPlatform) {
                                if (player.dx < 0) player.dx *= Game.Constants.FRICTION;
                                player.dx = Math.min(player.dx + 0.4, Game.State.playerSpeed);
                            } else {
                                player.dx = Game.State.playerSpeed;
                            }
                        } else if (player.onGround) {
                            if (onSlipperyPlatform) {
                                player.dx *= Game.Constants.FRICTION;
                            } else {
                                player.dx = 0;
                            }
                        }

                        if (Math.abs(player.dx) < 0.1) player.dx = 0;

                        if ((keys.up || keys.a) && player.onGround && Game.State.canJump) {
                            if (player.isCrouching && player.standingOnPlatform && player.standingOnPlatform !== Game.State.platforms[0] && player.canDropDown) {
                                player.dy = -2;
                                player.onGround = false;
                                player.platformToDropThrough = player.standingOnPlatform;
                                player.canDropDown = false;
                                setTimeout(() => { player.canDropDown = true; }, 300);
                            } else if (!player.isCrouching) {
                                player.dy = Game.Constants.JUMP_POWER;
                                player.onGround = false;
                                Game.State.canJump = false;
                                setTimeout(() => { Game.State.canJump = true; }, Game.State.jumpDelay);
                            }
                        }
                    }

                    // Action Button (B) logic for power-ups
                    if (keys.b && player.powerUp) {
                        if (player.powerUp.type === 'HAMMER' && player.attackTimer <= 0) {
                            player.isAttacking = true;
                            player.attackTimer = 30; // 0.5s cooldown
                            player.dx = 0; // Stop horizontal movement
                        } else if (player.powerUp.type === 'SHIELD') {
                            player.isBlocking = true;
                        }
                    } else {
                        player.isBlocking = false;
                    }
                },
                updateActions: function() {
                    const player = Game.State.player;
                    // Hammer attack timer and collision
                    if (player.attackTimer > 0) {
                        player.attackTimer--;
                        if (player.isAttacking && player.attackTimer === 25) { // Check collision mid-swing
                            const attackOffset = 5;
                            const attackWidth = 25;
                            const attackX = player.direction === 'right' ? player.x + player.width + attackOffset : player.x - attackWidth - attackOffset;
                            const attackY = player.y;
                            const attackHeight = player.height;

                            Game.State.enemies.forEach(enemy => {
                                if (attackX < enemy.x + enemy.width && attackX + attackWidth > enemy.x &&
                                    attackY < enemy.y + enemy.height && attackY + attackHeight > enemy.y) {
                                    
                                    const isOnSlippery = enemy.platform && enemy.platform.slippery;
                                    const knockbackForce = isOnSlippery ? 15 : 8;
                                    enemy.knockbackDx = player.direction === 'right' ? knockbackForce : -knockbackForce;
                                }
                            });
                        }
                        if (player.attackTimer === 0) {
                            player.isAttacking = false;
                        }
                    }
                },
                updatePlayerPosition: function() {
                    const player = Game.State.player;
                    player.dy += Game.Constants.GRAVITY;
                    player.x += player.dx;
                    player.y += player.dy;
                    if (player.x + player.width < 0) { player.x = Game.State.canvas.width; }
                    else if (player.x > Game.State.canvas.width) { player.x = -player.width; }
                },
                checkPlayerCollisions: function() {
                    const player = Game.State.player;
                    player.onGround = false;
                    player.standingOnPlatform = null;
                    
                    for (const platform of Game.State.platforms) {
                        if(player.platformToDropThrough === platform && player.y < platform.y) continue;
                        if(player.platformToDropThrough === platform && player.y > platform.y + platform.height) player.platformToDropThrough = null;

                        if (player.x + player.width > platform.x && player.x < platform.x + platform.width && player.dy >= 0 && player.y + player.height >= platform.y && (player.y + player.height - player.dy) <= platform.y) {
                            player.dy = 0;
                            player.onGround = true;
                            player.y = platform.y - player.height;
                            player.standingOnPlatform = platform;
                        }
                    }

                    for (const enemy of Game.State.enemies) {
                         if (player.x + player.width > enemy.x && player.x < enemy.x + enemy.width && player.y + player.height > enemy.y && player.y < enemy.y + enemy.height) {
                            const isFrontalCollision = (player.direction === 'right' && enemy.x >= player.x) || (player.direction === 'left' && enemy.x <= player.x);
                            if (player.isBlocking && isFrontalCollision) {
                                player.dx += player.direction === 'right' ? -2 : 2; // Knockback player
                            } else if (!player.isHit) {
                                player.isHit = true;
                                player.hitTimer = 30;
                            }
                         }
                    }
                    for (let i = Game.State.projectiles.length - 1; i >= 0; i--) {
                        const proj = Game.State.projectiles[i];
                         if (player.x + player.width > proj.x && player.x < proj.x + proj.width && player.y + player.height > proj.y && player.y < proj.y + proj.height) {
                            const isFrontalCollision = (player.direction === 'right' && proj.dx < 0) || (player.direction === 'left' && proj.dx > 0);
                             if (player.isBlocking && isFrontalCollision) {
                                 Game.State.projectiles.splice(i, 1);
                             } else if (!player.isHit) {
                                 player.isHit = true;
                                 player.hitTimer = 30;
                                 Game.State.projectiles.splice(i, 1);
                             }
                         }
                    }
                    
                    if (player.powerUpCooldown === 0) {
                        for (let i = Game.State.powerUps.length - 1; i >= 0; i--) {
                            const p = Game.State.powerUps[i];
                            if (player.x < p.x + p.width && player.x + player.width > p.x && player.y < p.y + p.height && player.y + player.height > p.y) {
                                const currentPowerUp = player.powerUp;
                                player.powerUp = p;
                                player.powerUpCooldown = 30;
                                if (currentPowerUp) {
                                    Game.State.powerUps[i] = currentPowerUp;
                                    currentPowerUp.x = p.x;
                                    currentPowerUp.y = p.y;
                                } else {
                                    Game.State.powerUps.splice(i, 1);
                                }
                                break;
                            }
                        }
                    }
                }
            },
            
            // --- ENEMIES MODULE ---
            Enemies: {
                generateEnemies: function() {
                    Game.State.enemies = [];
                    Game.State.projectiles = [];
                    const platform = Game.State.platforms[1];
                    Game.State.enemies.push({type: 'GROUND_MONSTER', width: 25, height: 25, x: platform.x + 50, y: platform.y - 25, dx: Game.State.enemySpeed, platform: platform, attackCooldown: 120, knockbackDx: 0, knockbackFriction: 0.9 });
                },
                updateEnemies: function() {
                    const S = Game.State;
                    S.enemies.forEach(e => {
                        if (e.knockbackDx !== 0) {
                            e.x += e.knockbackDx;
                            e.knockbackDx *= e.knockbackFriction;
                            if (Math.abs(e.knockbackDx) < 0.5) e.knockbackDx = 0;
                        } else if (e.type === 'GROUND_MONSTER') {
                            e.x += e.dx;
                            if (e.x <= e.platform.x || e.x + e.width >= e.platform.x + e.platform.width) {
                                e.dx *= -1;
                            }
                            e.attackCooldown--;
                            if (e.attackCooldown <= 0) {
                                S.projectiles.push({x: e.x + (e.width/2), y: e.y + 10, dx: e.dx > 0 ? 4 : -4, width: 8, height: 8});
                                e.attackCooldown = 120;
                            }
                        }
                    });
                },
                updateProjectiles: function() {
                     for (let i = Game.State.projectiles.length - 1; i >= 0; i--) {
                        const p = Game.State.projectiles[i];
                        p.x += p.dx;
                        if (p.x < 0 || p.x > Game.State.canvas.width) {
                            Game.State.projectiles.splice(i, 1);
                        }
                    }
                }
            },

            // --- GRAPHICS MODULE ---
            Graphics: {
                draw: function() {
                    this.drawBackground();
                    Game.State.platforms.forEach(p => { 
                        Game.State.ctx.fillStyle = p.slippery ? '#A8D8F0' : '#FFFFFF';
                        Game.State.ctx.fillRect(p.x, p.y, p.width, p.height); 
                    });
                    Game.State.enemies.forEach(e => {
                        Game.State.ctx.fillStyle = '#ff80ed';
                        Game.State.ctx.fillRect(e.x, e.y, e.width, e.height);
                    });
                     Game.State.projectiles.forEach(p => {
                        Game.State.ctx.fillStyle = '#bdeeff';
                        Game.State.ctx.fillRect(p.x, p.y, p.width, p.height);
                    });
                    this.drawPowerUps();
                    this.drawCharacter('ESKIMO', Game.State.player.x, Game.State.player.y, Game.State.player.isCrouching);
                },
                drawPowerUps: function() {
                    const ctx = Game.State.ctx;
                    Game.State.powerUps.forEach(p => {
                        if (p.type === 'HAMMER') {
                           this.drawHammer(p.x, p.y);
                        } else if (p.type === 'SHIELD') {
                            this.drawShieldFrontView(p.x, p.y);
                        }
                    });
                },
                drawHammer: function(x, y, targetCtx = Game.State.ctx) {
                    targetCtx.fillStyle = '#8B4513'; // Handle
                    targetCtx.fillRect(x + 10, y + 10, 5, 15);
                    targetCtx.fillStyle = '#C0C0C0'; // Head
                    targetCtx.fillRect(x, y, 25, 10);
                },
                drawShieldFrontView: function(x, y, targetCtx = Game.State.ctx) {
                    targetCtx.fillStyle = '#4682B4'; // Blue part
                    targetCtx.beginPath();
                    targetCtx.moveTo(x, y);
                    targetCtx.lineTo(x + 25, y);
                    targetCtx.lineTo(x + 25, y + 20);
                    targetCtx.arcTo(x + 12.5, y + 30, x, y + 20, 15);
                    targetCtx.closePath();
                    targetCtx.fill();
                    targetCtx.fillStyle = '#C0C0C0'; // Silver border
                    targetCtx.fillRect(x, y, 25, 3);
                },
                drawShieldSideView: function(x, y, targetCtx = Game.State.ctx) {
                    targetCtx.fillStyle = '#C0C0C0'; // Silver edge
                    targetCtx.fillRect(x, y, 4, 25);
                    targetCtx.fillStyle = '#4682B4'; // Blue face
                    targetCtx.fillRect(x + 4, y, 3, 25);
                },
                drawCharacter: function(charType, x, y, isCrouching = false, targetCtx = Game.State.ctx) {
                    const player = Game.State.player;
                    if (player.isHit && Math.floor(Game.State.globalAnimationTick / 4) % 2 === 0) {
                        return;
                    }
                    
                    const showHeldItem = player.powerUp && !player.isAttacking && !player.isBlocking;

                    if (showHeldItem) {
                        const itemX = x + player.width / 2;
                        const itemY = y + player.height / 2 - 5;
                        targetCtx.save();
                        targetCtx.translate(itemX, itemY);
                        if (player.powerUp.type === 'HAMMER') {
                            targetCtx.rotate(-Math.PI / 6); this.drawHammer(-12.5, -15, targetCtx);
                        } else if (player.powerUp.type === 'SHIELD') {
                            targetCtx.rotate(Math.PI / 8); this.drawShieldFrontView(-12.5, -15, targetCtx);
                        }
                        targetCtx.restore();
                    }

                    // Draw player body
                    let heightModifier = isCrouching ? 6 : 0;
                    let yOffset = isCrouching ? 6 : 0;
                    targetCtx.fillStyle = '#8B4513'; targetCtx.fillRect(x + 2, y + yOffset, player.width - 4, player.height - 2 - heightModifier);
                    targetCtx.fillStyle = '#4682B4'; targetCtx.fillRect(x, y + player.height - 8, player.width, 5);
                    targetCtx.fillStyle = '#FFDAB9'; targetCtx.fillRect(x + 7, y + 5 + yOffset, player.width - 14, 12 - heightModifier);
                    targetCtx.fillStyle = '#000000'; targetCtx.fillRect(x + 10, y + 10 + yOffset, 3, 3); targetCtx.fillRect(x + 17, y + 10 + yOffset, 3, 3);
                    if (!isCrouching) {
                        targetCtx.fillStyle = '#8B4513'; const armY = y + 15; const animOffset = Math.sin(Game.State.globalAnimationTick * 0.2) * 3;
                        targetCtx.fillRect(x - 2, armY + animOffset, 4, 8); targetCtx.fillRect(x + player.width - 2, armY - animOffset, 4, 8);
                    }
                    const legY = y + player.height - 2; targetCtx.fillRect(x + 5, legY, 8, 5); targetCtx.fillRect(x + player.width - 13, legY, 8, 5);

                    // Draw active power-ups (in front)
                    if (player.isBlocking) {
                        const shieldX = player.direction === 'right' ? x + player.width - 4 : x;
                        this.drawShieldSideView(shieldX, y + 2, targetCtx);
                    } else if (player.isAttacking) {
                        // Set pivot point to player's hand position
                        const armY = y + 15;
                        const pivotX = player.direction === 'right' ? x + player.width - 2 : x + 2;
                        const pivotY = armY;

                        targetCtx.save();
                        targetCtx.translate(pivotX, pivotY);

                        // Animate the swing
                        const swingProgress = (30 - player.attackTimer) / 30;
                        const swingAngle = Math.sin(swingProgress * Math.PI) * (Math.PI / 1.5);
                        targetCtx.rotate(player.direction === 'right' ? swingAngle : -swingAngle);

                        // Draw hammer relative to the hand pivot, positioning the handle correctly
                        this.drawHammer(-12.5, -25, targetCtx);
                        
                        targetCtx.restore();
                    }
                },
                drawBackground: function() {
                    const ctx = Game.State.ctx; const canvas = Game.State.canvas;
                    const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    sky.addColorStop(0, '#0c1445'); sky.addColorStop(1, '#346888');
                    ctx.fillStyle = sky; ctx.fillRect(0, 0, canvas.width, canvas.height);
                },
            },
            
            // --- CONTROLS MODULE ---
            Controls: {
                keys: { left: false, right: false, up: false, down: false, a: false, b: false },
                setupEventListeners: function() {
                    document.addEventListener('keydown', (e) => {
                        const key = e.key.toLowerCase();
                        if (key === 'arrowleft') this.keys.left = true;
                        if (key === 'arrowright') this.keys.right = true;
                        if (key === 'arrowup' || key === 'd') { e.preventDefault(); this.keys.up = true; this.keys.a = true; }
                        if (key === 'arrowdown') this.keys.down = true;
                        if (key === 's') { e.preventDefault(); this.keys.b = true; }
                    });
                    document.addEventListener('keyup', (e) => {
                        const key = e.key.toLowerCase();
                        if (key === 'arrowleft') this.keys.left = false;
                        if (key === 'arrowright') this.keys.right = false;
                        if (key === 'arrowup' || key === 'd') { this.keys.up = false; this.keys.a = false; }
                        if (key === 'arrowdown') this.keys.down = false;
                        if (key === 's') { this.keys.b = false; }
                    });

                    const btnMap = {
                        'btn-left': { key: 'left' }, 'btn-right': { key: 'right' },
                        'btn-down': { key: 'down' }, 'btn-up': { key: 'up' },
                        'btn-a': { key: 'a' }, 'btn-b': { key: 'b' }
                    };
                    
                    // Remap button A to also trigger 'up' for jumping
                    btnMap['btn-a'].alsoTriggers = 'up';

                    for (const [id, config] of Object.entries(btnMap)) {
                        const element = document.getElementById(id);
                        const handlePress = (isPressed) => (e) => {
                            e.preventDefault();
                            this.keys[config.key] = isPressed;
                            if (config.alsoTriggers) this.keys[config.alsoTriggers] = isPressed;
                            element.classList.toggle('pressed', isPressed);
                        };
                        element.addEventListener('touchstart', handlePress(true), { passive: false });
                        element.addEventListener('touchend', handlePress(false), { passive: false });
                        element.addEventListener('mousedown', handlePress(true));
                        element.addEventListener('mouseup', handlePress(false));
                        element.addEventListener('mouseleave', handlePress(false));
                    }
                }
            },
        };

        window.onload = function() { Game.Core.init(); };
    </script>
</body>
</html>

