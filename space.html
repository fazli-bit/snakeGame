<!DOCTYPE html>
<html lang="ms">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Permainan Tembakan Angkasa</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #000;
            color: #fff;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }
        .game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100vh;
            box-sizing: border-box;
        }
        .main-menu-wrapper {
            padding: 20px;
            background-color: #1a1a1a;
            border: 2px solid #00ff00;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 255, 0, 0.2);
            text-align: center;
            max-width: 640px;
            width: 90%;
        }

        .game-container.game-active-layout {
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 20px 0;
            max-width: 640px; 
            margin: 0 auto;
        }
        #game-area {
            flex: 2.5; 
            position: relative;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            border-left: 2px solid #00ff00;
            border-right: 2px solid #00ff00;
            border-top: 2px solid #00ff00;
            box-sizing: border-box;
        }
        #gamepad-area {
            flex: 1; 
            background-color: #111;
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 10px 30px;
            box-sizing: border-box;
            width: 100%;
            border: 2px solid #00ff00;
            border-top: none; 
        }
        
        #game-board-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: #000;
        }
        #game-canvas {
            width: 100%;
            height: 100%;
        }
        
        h1, h2, h3 { color: #00ff00; font-family: 'Press Start 2P', cursive; }

        #ship-selection { display: flex; gap: 20px; justify-content: center; align-items: center; margin-bottom: 20px; }
        #ship-selection button { background: none; border: 2px solid transparent; border-radius: 8px; padding: 10px; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 5px; }
        #ship-selection img { width: 80px; height: 80px; object-fit: contain; }
        #ship-selection p { margin: 0; font-size: 0.7rem; color: #ccc; }
        #ship-selection button.active { border-color: #00ff00; background-color: rgba(0, 255, 0, 0.1); }
        #ship-selection button.active p { color: #00ff00; }
        #start-game-button { background-color: #00ff00; color: #000; font-size: 1rem; padding: 15px 30px; margin-top: 15px; border: none; border-radius: 4px; cursor: pointer;}
        
        #ui-layer { position: absolute; top: 10px; left: 10px; right: 10px; display: flex; justify-content: space-between; font-size: 1rem; z-index: 10; pointer-events: none; text-shadow: 2px 2px #000; }
        #player-stats { display: flex; gap: 20px; }
        
        #game-board-wrapper.boss-active-bg::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(ellipse at center, rgba(255,0,0,0.4) 0%,rgba(255,0,0,0) 70%); z-index: 5; pointer-events: none; animation: pulse-red 2s infinite; }
        @keyframes pulse-red { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: none; justify-content: center; align-items: center; z-index: 100; }
        .modal-content { color: #fff; background-color: rgba(26, 26, 26, 0.9); padding: 30px; border-radius: 15px; border: 4px solid #555; text-align: center; box-shadow: 0 0 20px rgba(0,0,0,0.8); }
        .modal-content h2 { margin-top: 0; font-size: 1.8rem; color: #ff4136;}
        .modal-content button { padding: 10px 20px; margin: 5px; border: 1px solid #555; border-radius: 4px; background-color: #444; color: white; cursor: pointer; font-family: 'Press Start 2P', cursive; font-size: 0.8rem; }
        .modal-content input { background-color: #333; border: 2px solid #00ff00; color: #f0f0f0; padding: 8px; font-family: 'Press Start 2P', cursive; text-align: center; width: 200px; text-transform: uppercase; }

        #highscore-container { text-align: center; width: 100%; font-size: 0.7rem; margin-top: 20px;}
        #highscore-container h3 { margin-top: 0; margin-bottom: 15px; color: #ffff00; display: inline-block; margin-right: 10px;}
        #refresh-scores-button { background: none; border: none; font-size: 1rem; cursor: pointer; color: #fff; }
        .highscore-list ol, .highscore-columns-shared ol { list-style-type: none; padding-left: 0; margin: 0 auto; text-align: left; max-width: 350px; }
        .highscore-columns-shared { display: flex; justify-content: center; gap: 40px; }
        
        .highscore-list li, .highscore-columns-shared li { 
            margin-bottom: 8px; 
            color: #f0f0f0;
            display: flex;
            justify-content: space-between;
        }
        .highscore-list li span, .highscore-columns-shared li span { 
            color: #ffff00; 
        }

        #joystick-area { width: 120px; height: 120px; background-color: rgba(255, 255, 255, 0.1); border-radius: 50%; position: relative; }
        #joystick-handle { width: 60px; height: 60px; background-color: rgba(255, 255, 255, 0.3); border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 50%; position: absolute; top: 30px; left: 30px; }
        #action-buttons { display: flex; align-items: center; gap: 20px; }
        .action-button { width: 80px; height: 80px; border-radius: 50%; color: white; font-size: 2rem; display: flex; justify-content: center; align-items: center; border: 2px solid; }
        #fire-button { background-color: rgba(255, 0, 0, 0.3); border-color: rgba(255, 0, 0, 0.6); }
        #special-attack-button { background-color: rgba(0, 100, 255, 0.3); border-color: rgba(0, 100, 255, 0.6); }
        
        #toggle-instructions-button { background-color: transparent; border: 2px solid #555; color: #ccc; padding: 8px 15px; font-family: 'Press Start 2P', cursive; font-size: 0.7rem; cursor: pointer; border-radius: 4px; margin-top: 30px; }
        #toggle-instructions-button:hover { background-color: #333; }
        #instructions { border: 2px solid #555; border-radius: 8px; padding: 15px; margin-top: 10px; text-align: left; font-size: 0.7rem; line-height: 1.5; max-width: 400px; margin-left: auto; margin-right: auto; }
        #instructions h3 { margin-top: 0; text-align: center;}
        #instructions span { color: #ffff00; }

        #ship-stats-display {
            border: 2px solid #555;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            text-align: left;
            font-size: 0.7rem;
            line-height: 1.6;
            max-width: 300px;
            margin-left: auto;
            margin-right: auto;
            color: #ccc;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .stat-bar-container {
            width: 100px;
            height: 10px;
            background-color: #333;
            border: 1px solid #555;
            border-radius: 2px;
            overflow: hidden;
        }
        .stat-bar {
            height: 100%;
            background-color: #00ff00;
        }

    </style>
</head>
<body>

    <div class="game-container">
        <div id="main-menu" class="main-menu-wrapper">
            <h1>TEMBAKAN ANGKASA</h1>
            <p id="game-version"></p>
            <h2>PILIH KAPAL</h2>
            <div id="ship-selection"></div>
            <div id="ship-stats-display"></div>
            <button id="start-game-button">MULA</button>
            <button id="toggle-instructions-button">TUNJUK ARAHAN</button>
            <div id="instructions" style="display: none;">
                <h3>ARAHAN</h3>
                <b>Papan Kekunci:</b><br>
                <span>Anak Panah/WASD:</span> Bergerak<br>
                <span>Spacebar:</span> Tembak<br>
                <span>B:</span> Serangan Istimewa<br>
                <b>Skrin Sentuh:</b><br>
                <span>Joystick Kiri:</span> Bergerak<br>
                <span>Butang Merah:</span> Tembak<br>
                <span>Butang Biru:</span> Serangan Istimewa
            </div>
            <div id="highscore-container">
                <h3>MARKAH TERTINGGI</h3><button id="refresh-scores-button">üîÑ</button>
                <div class="highscore-list">
                    <ol id="highscore-list"></ol>
                </div>
            </div>
        </div>
        
        <div id="game-area" style="display: none;">
            <div id="game-board-wrapper">
                 <canvas id="game-canvas"></canvas>
                 <div id="ui-layer">
                     <div id="player-stats">
                        <span id="score">SKOR: 0</span>
                        <span id="bombs">üí£: 0</span>
                     </div>
                     <span id="stage">PERINGKAT: 1</span>
                 </div>
            </div>
        </div>
        
        <div id="gamepad-area" style="display: none;">
             <div id="joystick-area">
                 <div id="joystick-handle"></div>
             </div>
             <div id="action-buttons">
                <button id="special-attack-button" class="action-button">‚ú®</button>
                <button id="fire-button" class="action-button">üî•</button>
             </div>
        </div>

        <div id="game-over-modal" class="modal-overlay">
            <div class="modal-content">
                <h2>PERMAINAN TAMAT</h2>
                <div id="new-highscore-entry" style="display: none;">
                    <p>MARKAH TINGGI BAHARU!</p>
                    <input type="text" id="player-name" maxlength="10" placeholder="MASUKKAN NAMA">
                    <button id="save-score-button">SIMPAN</button>
                </div>
                 <div id="game-over-scores" style="display: none;">
                    <h3>10 MARKAH TERTINGGI</h3>
                    <div class="highscore-columns-shared" id="highscore-columns-gameover">
                        <ol id="gos-list-1"></ol> <ol id="gos-list-2"></ol>
                    </div>
                </div>
                <button id="continue-button">MAIN SEMULA</button>
                <button id="main-menu-button">MENU UTAMA</button>
            </div>
        </div>
    </div>
    
    <script type="module">
       import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
       import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
       import { getFirestore, collection, doc, setDoc, getDocs, getDoc, query, orderBy, limit } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
       
       window.firebase = {
           initializeApp, getAuth, signInAnonymously, getFirestore, collection, doc, setDoc, getDocs, getDoc, query, orderBy, limit
       };
    </script>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const GAME_VERSION = "1.2.0";
    
    // --- KONFIGURASI ASET ---
    const interceptorConfig = { "id": "interceptor", "name": "Interceptor", "type": "Pemain", "drawOrder": [ "engineFlame", "body", "cockpit", "wings" ], "parts": { "body": { "shape": "polygon", "color": "#c0c0c0", "x": 0, "y": 0, "rotation": 0, "points": [ 0, -25, -15, 20, 0, 10, 15, 20 ], "scaleX": 100, "scaleY": 100 }, "cockpit": { "shape": "polygon", "color": "#4d94ff", "x": 0, "y": -5, "rotation": 0, "points": [ 0, -15, -8, 5, 8, 5 ], "scaleX": 67, "scaleY": 100 }, "wings": { "shape": "polygon", "color": "#a0a0a0", "x": 0, "y": 13, "rotation": 0, "points": [ -25, 0, 25, 0, 0, -10 ], "scaleX": 126, "scaleY": 118 }, "engineFlame": { "shape": "polygon", "color": "#ffcc00", "x": 0, "y": 16, "rotation": 0, "points": [ -7, 0, 7, 0, 0, 15 ], "scaleX": 100, "scaleY": 100, "animation": { "property": "opacity", "speed": 10, "amplitude": 0.5 } } } };
    const assaultConfig = { "id": "assault", "name": "Assault", "type": "Pemain", "drawOrder": [ "body", "wings", "cockpit", "cannons" ], "parts": { "body": { "shape": "rect", "color": "#808080", "x": 0, "y": 0, "rotation": 0, "width": 49, "height": 49 }, "wings": { "shape": "rect", "color": "#a0a0a0", "x": 0, "y": 0, "rotation": 45, "width": 50, "height": 47 }, "cockpit": { "shape": "rect", "color": "#ff6600", "x": 0, "y": 19, "rotation": 0, "width": 24, "height": 22 }, "cannons": { "shape": "rect", "color": "#666666", "x": 0, "y": -2, "rotation": 89, "width": 53, "height": 5 } } };
    const bomberConfig = { "id": "bomber", "name": "Bomber", "type": "Pemain", "drawOrder": [ "body", "wings", "pods" ], "parts": { "body": { "shape": "rect", "color": "#003300", "x": 0, "y": -1, "rotation": 0, "width": 19, "height": 49 }, "wings": { "shape": "polygon", "color": "#006400", "x": 0, "y": 19, "rotation": 180, "points": [ -40, 0, 40, 0, 20, 10, -20, 10 ], "scaleX": 126, "scaleY": 101 }, "pods": { "shape": "polygon", "color": "#556b2f", "x": 0, "y": -26, "rotation": 0, "points": [ -10, 10, 10, 10, 0, -10 ], "scaleX": 83, "scaleY": 200 } } };
    const droneConfig = { "id": "drone", "name": "Drone", "type": "Musuh", "hp": 1, "drawOrder": [ "body", "eye" ], "parts": { "body": { "shape": "circle", "color": "#4b0082", "x": 0, "y": 0, "rotation": 0, "r": 20 }, "eye": { "shape": "circle", "color": "#ff0000", "x": 0, "y": 8, "rotation": 0, "r": 7, "animation": { "property": "opacity", "speed": 2, "amplitude": 0.5 } } } };
    const fighterConfig = { "id": "fighter", "name": "Fighter", "type": "Musuh", "hp": 2, "drawOrder": [ "body", "cockpit" ], "parts": { "body": { "shape": "polygon", "color": "#8b0000", "x": 0, "y": 0, "rotation": 0, "points": [ 0, -20, -25, 20, 0, 10, 25, 20 ], "scaleX": 140, "scaleY": 115 }, "cockpit": { "shape": "polygon", "color": "#363636", "x": 0, "y": -2, "rotation": 179, "points": [ 0, -10, -5, 5, 5, 5 ], "scaleX": 159, "scaleY": 100 } } };
    const cruiserConfig = { "id": "cruiser", "name": "Cruiser", "type": "Musuh", "hp": 5, "drawOrder": [ "lowerHull", "upperHull", "bridge" ], "parts": { "lowerHull": { "shape": "rect", "color": "#800000", "x": 0, "y": 0, "rotation": 0, "width": 50, "height": 25 }, "upperHull": { "shape": "rect", "color": "#a52a2a", "x": 0, "y": -2, "rotation": 0, "width": 30, "height": 40 }, "bridge": { "shape": "rect", "color": "#ffc0cb", "x": 0, "y": -12, "rotation": 0, "width": 10, "height": 15 } } };
    const scoutConfig = { "id": "scout", "name": "Scout", "type": "Musuh", "hp": 1, "drawOrder": [ "wings", "body" ], "parts": { "body": { "shape": "polygon", "color": "#00ff00", "x": 0, "y": 5, "rotation": 0, "points": [ 0, -15, -10, 10, 10, 10 ], "scaleX": 156, "scaleY": 81 }, "wings": { "shape": "polygon", "color": "#adff2f", "x": 0, "y": 0, "rotation": 0, "points": [ -20, 0, 0, -10, 20, 0, 0, 5 ], "scaleX": 140, "scaleY": 165 } } };
    const kamikazeConfig = { "id": "kamikaze", "name": "Kamikaze", "type": "Musuh", "hp": 1, "drawOrder": [ "body", "stripes" ], "parts": { "body": { "shape": "polygon", "color": "#444444", "x": 0, "y": 0, "rotation": 0, "points": [ 0, -25, -10, 25, 10, 25 ], "scaleX": 200, "scaleY": 130 }, "stripes": { "shape": "rect", "color": "#ffff00", "x": 0, "y": 17, "rotation": 0, "width": 14, "height": 22 } } };
    
    // --- KONFIGURASI BOS ---
    const bossTitanConfig = { "id": "boss-titan", "name": "Boss Titan", "type": "Boss", "hp": 200, "drawOrder": [ "base", "armor", "bridge", "mainCannon", "sideCannons" ], "parts": { "base": { "shape": "rect", "color": "#696969", "x": 0, "y": 0, "rotation": 0, "width": 80, "height": 80 }, "armor": { "shape": "rect", "color": "#808080", "x": 0, "y": 0, "rotation": 0, "width": 100, "height": 36 }, "bridge": { "shape": "rect", "color": "#dcdcdc", "x": 0, "y": 16, "rotation": 0, "width": 51, "height": 21 }, "mainCannon": { "shape": "circle", "color": "#ff4500", "x": 0, "y": -9, "rotation": 0, "r": 12, "animation": { "property": "opacity", "speed": 1, "amplitude": 0.5 } }, "sideCannons": { "shape": "rect", "color": "#a9a9a9", "x": 0, "y": 2, "rotation": 0, "width": 27, "height": 32 } } };
    const bossViperConfig = { "id": "boss-viper", "name": "Boss Viper", "type": "Boss", "hp": 200, "drawOrder": ["Base", "armor", "mainCannon", "leftCannon", "rightCannon", "bridge"], "parts": { "Base": { "shape": "polygon", "color": "#284fc3", "x": 0, "y": 0, "rotation": 36, "points": [0, -25, 24, -8, 15, 20, -15, 20, -24, -8], "scaleX": 145, "scaleY": 145 }, "armor": { "shape": "polygon", "color": "#27396d", "x": 0, "y": 17, "rotation": 0, "points": [0, -50, 50, -29, 0, 20, 0, 20, -50, -29], "scaleX": 100, "scaleY": 100 }, "bridge": { "shape": "circle", "color": "#e09c0b", "x": 0, "y": -17, "rotation": 0, "r": 20, "animation": { "property": "opacity", "speed": 15.5, "amplitude": 0.5 } }, "mainCannon": { "shape": "polygon", "color": "#721196", "x": 0, "y": 43, "rotation": 180, "points": [-15, 15, 15, 15, 0, -15] }, "leftCannon": { "shape": "rect", "color": "#186472", "x": -44, "y": 13, "rotation": 0, "width": 12, "height": 56 }, "rightCannon": { "shape": "rect", "color": "#186472", "x": 44, "y": 13, "rotation": 0, "width": 12, "height": 56 } } };
    const bossSerpentConfig = { "id": "boss-serpent", "name": "Boss Serpent", "type": "Boss", "hp": 200, "drawOrder": ["head", "body1", "body2", "body3", "body4"], "parts": { "head": { "shape": "polygon", "color": "#006400", "x": 0, "y": -40, "rotation": 0, "points": [0, -20, 15, 15, -15, 15] }, "body1": { "shape": "circle", "color": "#556b2f", "x": 10, "y": -15, "rotation": 0, "r": 18 }, "body2": { "shape": "circle", "color": "#6B8E23", "x": -10, "y": 15, "rotation": 0, "r": 15 }, "body3": { "shape": "circle", "color": "#808000", "x": 10, "y": 40, "rotation": 0, "r": 12 }, "body4": { "shape": "polygon", "color": "#ADFF2F", "x": 0, "y": 60, "rotation": 0, "points": [0, 20, 10, -10, -10, -10] } } };

    const bossConfigs = [bossTitanConfig, bossViperConfig, bossSerpentConfig];

    // Konfigurasi Firebase
    const firebaseConfig = { apiKey: "AIzaSyBDuQgpyrVT-hOYucH51AATLxDRLaKWgpQ", authDomain: "retro-game-6d9c7.firebaseapp.com", projectId: "retro-game-6d9c7", storageBucket: "retro-game-6d9c7.firebasestorage.app", messagingSenderId: "258289584699", appId: "1:258289584699:web:d9228a2a2e3cbc0b41aa1e", measurementId: "G-G16BRQJB7D" };

    const playerConfigs = { interceptor: interceptorConfig, assault: assaultConfig, bomber: bomberConfig };
    const enemyTypes = { drone: droneConfig, fighter: fighterConfig, cruiser: cruiserConfig, scout: scoutConfig, kamikaze: kamikazeConfig };
    
    const shipImageUrls = {
        interceptor: "https://raw.githubusercontent.com/fazli-bit/snakeGame/refs/heads/png/interceptor.png",
        assault: "https://raw.githubusercontent.com/fazli-bit/snakeGame/refs/heads/png/assault.png",
        bomber: "https://raw.githubusercontent.com/fazli-bit/snakeGame/refs/heads/png/bomber.png"
    };
    
    const shipStats = {
        interceptor: { hp: 1, maxHp: 2, startingBombs: 1, bombPickupAmount: 1, fireRate: 150, bulletCount: 1, maxBulletCount: 3 },
        assault: { hp: 2, maxHp: 3, startingBombs: 1, bombPickupAmount: 1, fireRate: 300, bulletCount: 1, maxBulletCount: 2 },
        bomber: { hp: 1, maxHp: 2, startingBombs: 2, bombPickupAmount: 2, fireRate: 200, bulletCount: 1, maxBulletCount: 2 }
    };
    
    // --- KELAS-KELAS PERMAINAN ---

    class GameObject {
        constructor(config, x, y, size) { this.config = config; this.x = x; this.y = y; this.size = size; this.isAlive = true; }
        draw(ctx, time) {
            const scale = this.size / 100;
            ctx.save();
            ctx.translate(this.x, this.y);
            this.config.drawOrder.forEach(partName => {
                const part = this.config.parts[partName];
                if (part) this.drawPart(ctx, part, scale, time);
            });
            ctx.restore();
        }
        drawPart(ctx, part, s, time) {
            ctx.save();
            ctx.fillStyle = part.color;
            let animX = 0, animY = 0;
            if (part.animation) {
                const animValue = Math.sin(time * part.animation.speed) * part.animation.amplitude;
                if (part.animation.property === 'y') animY = animValue;
                if (part.animation.property === 'x') animX = animValue;
                if (part.animation.property === 'opacity') ctx.globalAlpha = 0.5 + (animValue + part.animation.amplitude) / (part.animation.amplitude * 2);
            }
            ctx.translate(((part.x || 0) + animX) * s, ((part.y || 0) + animY) * s);
            ctx.rotate((part.rotation || 0) * Math.PI / 180);
            switch (part.shape) {
                case 'polygon':
                    ctx.beginPath();
                    const scaleX = (part.scaleX || 100) / 100;
                    const scaleY = (part.scaleY || 100) / 100;
                    const scaledPoints = part.points.map((p, i) => i % 2 === 0 ? p * scaleX : p * scaleY);
                    ctx.moveTo(scaledPoints[0] * s, scaledPoints[1] * s);
                    for (let i = 2; i < scaledPoints.length; i += 2) ctx.lineTo(scaledPoints[i] * s, scaledPoints[i+1] * s);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'rect': ctx.fillRect(-(part.width / 2) * s, -(part.height / 2) * s, part.width * s, part.height * s); break;
                case 'circle': ctx.beginPath(); ctx.arc(0, 0, (part.r || part.radius) * s, 0, Math.PI * 2); ctx.fill(); break;
            }
            ctx.restore();
        }
    }
    class Player extends GameObject {
        constructor(config, stats, boardWidth, boardHeight) {
            super(config, boardWidth / 2, boardHeight - 50, 55);
            this.boardWidth = boardWidth; 
            this.boardHeight = boardHeight;
            this.speed = 5; 
            this.canShoot = true; 
            
            this.hp = stats.hp;
            this.maxHp = stats.maxHp;
            this.bombs = stats.startingBombs;
            this.bombPickupAmount = stats.bombPickupAmount;
            this.shootCooldown = stats.fireRate;
            this.bulletCount = stats.bulletCount;
            this.maxBulletCount = stats.maxBulletCount;
        }
        update(keys, touchDx, touchDy) {
            let dx = 0; 
            let dy = 0;
            
            if (keys['ArrowLeft'] || keys['a']) dx = -1;
            else if (keys['ArrowRight'] || keys['d']) dx = 1;

            if (keys['ArrowUp'] || keys['w']) dy = -1;
            else if (keys['ArrowDown'] || keys['s']) dy = 1;
            
            if (touchDx !== 0 || touchDy !== 0) {
                dx = touchDx;
                dy = touchDy;
            }

            this.x += dx * this.speed; this.y += dy * this.speed;
            if (this.x < this.size / 2) this.x = this.size / 2;
            if (this.x > this.boardWidth - this.size / 2) this.x = this.boardWidth - this.size / 2;
            if (this.y < this.size / 2) this.y = this.size / 2;
            if (this.y > this.boardHeight - this.size / 2) this.y = this.boardHeight - this.size / 2;
        }
        shoot() {
            if (this.canShoot) {
                this.canShoot = false;
                setTimeout(() => { this.canShoot = true; }, this.shootCooldown);
                
                const projectiles = [];
                const spread = 10;
                const startX = this.x - (spread * (this.bulletCount - 1)) / 2;
                
                for (let i = 0; i < this.bulletCount; i++) {
                    projectiles.push(new Projectile(startX + (i * spread), this.y - 20, 'player'));
                }
                return projectiles;
            }
            return null;
        }
        takeDamage() {
            this.hp--;
            if (this.hp <= 0) {
                this.isAlive = false;
            }
        }
        addShield() {
            if (this.hp < this.maxHp) {
                this.hp++;
            }
        }
        addBombs() {
            this.bombs += this.bombPickupAmount;
        }
        addBullet() {
            if (this.bulletCount < this.maxBulletCount) {
                this.bulletCount++;
            }
        }
        useBomb(game) {
            if (this.bombs > 0) {
                this.bombs--;
                game.triggerSpecialAttack();
                return true;
            }
            return false;
        }
        drawShield(ctx) {
            if (this.hp <= 1) return;
            const shieldCount = this.hp - 1;
            ctx.save();
            ctx.translate(this.x, this.y);
            
            for(let i = 1; i <= shieldCount; i++) {
                const alpha = 0.2 + (i * 0.2);
                ctx.fillStyle = `rgba(102, 217, 255, ${alpha})`;
                ctx.strokeStyle = `rgba(150, 230, 255, ${alpha + 0.2})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, (this.size * 0.5) + (i * 5), Math.PI * 1.15, Math.PI * 1.85);
                ctx.fill();
                ctx.stroke();
            }
            ctx.restore();
        }
    }
    class Enemy extends GameObject {
        constructor(config, x, y, game) {
            super(config, x, y, 50);
            this.hp = config.hp || 1;
            if (!(this instanceof Boss)) {
                const extraHp = Math.floor((game.stage - 1) / 2);
                this.hp += extraHp;
            }
            this.pattern = null; 
            this.initialX = x; this.initialY = y; this.age = 0;
            this.canShoot = true;
            this.shootCooldown = 2000 + Math.random() * 2000;
            this.squadId = null;
        }
        update(player, game) { 
            if (this.pattern) this.pattern(this, player);
            this.age++;
            if (this.y > 0 && this.canShoot && Math.random() < 0.01) {
                const p = this.shoot();
                if (p) game.projectiles.push(p);
            }
        }
        shoot() {
            this.canShoot = false;
            setTimeout(() => { this.canShoot = true; }, this.shootCooldown);
            return new Projectile(this.x, this.y + this.size / 2, 'enemy');
        }
    }
    class Boss extends Enemy {
        constructor(config, x, y, game) {
            super(config, x, y, game);
            this.size = 150;
            this.shootCooldown = 800;
            this.attackPatternCounter = 0;
            this.spiralAngle = 0;
        }
        update(player, game) {
             if (this.pattern) this.pattern(this, player);
            this.age++;
            if (this.y > 0 && this.canShoot && Math.random() < 0.05) {
                this.shoot(game);
            }
        }
        shoot(game) {
            this.canShoot = false;
            const stageCooldownReduction = Math.min(game.stage * 50, 300);
            setTimeout(() => { this.canShoot = true; }, this.shootCooldown - stageCooldownReduction);
            this.attackPatternCounter++;

            // --- PENAMBAHBAIKAN: Corak serangan berbeza untuk setiap bos ---
            if (this.config.id === 'boss-viper') {
                if (this.attackPatternCounter % 5 === 0) { // Laser Beam Attack
                    const laser = new Laser(this.x, this.y + this.size / 2, game.canvas.width, 120);
                    game.lasers.push(laser);
                } else { // Normal Shot
                    game.projectiles.push(new Projectile(this.x - 40, this.y + this.size / 3, 'enemy', -1, 5));
                    game.projectiles.push(new Projectile(this.x + 40, this.y + this.size / 3, 'enemy', 1, 5));
                }
            } else if (this.config.id === 'boss-serpent') {
                if (this.attackPatternCounter % 3 === 0) { // Spiral Shot
                    const bulletsPerSpiral = 10;
                    for (let i = 0; i < bulletsPerSpiral; i++) {
                        const angle = this.spiralAngle + (i * (2 * Math.PI / bulletsPerSpiral));
                        const speed = 3;
                        const dx = Math.cos(angle) * speed;
                        const dy = Math.sin(angle) * speed;
                        game.projectiles.push(new Projectile(this.x, this.y, 'enemy', dx, dy));
                    }
                    this.spiralAngle += 0.5;
                } else { // Normal shot
                     game.projectiles.push(new Projectile(this.x, this.y, 'enemy', 0, 5));
                }
            } else { // Default: Boss Titan
                if (this.attackPatternCounter % 4 === 0) { 
                    const bulletCount = game.stage >= 3 ? 5 : 3;
                    const speed = 4 + (game.stage >= 3 ? 1 : 0);
                    const spread = 2;
                    if (bulletCount % 2 !== 0) { game.projectiles.push(new Projectile(this.x, this.y + this.size / 2, 'enemy', 0, speed + 1)); }
                    for (let i = 1; i <= Math.floor(bulletCount / 2); i++) {
                        game.projectiles.push(new Projectile(this.x, this.y + this.size / 2, 'enemy', -spread * i, speed));
                        game.projectiles.push(new Projectile(this.x, this.y + this.size / 2, 'enemy', spread * i, speed));
                    }
                } else {
                    const bulletCount = game.stage >= 2 ? 2 : 1;
                    const spread = 40;
                    if (bulletCount === 1) { game.projectiles.push(new Projectile(this.x, this.y + this.size / 2, 'enemy', 0, 6)); } 
                    else {
                        game.projectiles.push(new Projectile(this.x - spread, this.y + this.size / 2, 'enemy', 0, 6));
                        game.projectiles.push(new Projectile(this.x + spread, this.y + this.size / 2, 'enemy', 0, 6));
                    }
                }
            }
        }
    }
    class Projectile {
        constructor(x, y, owner, dx = 0, dy = (owner === 'player' ? -8 : 5)) {
            this.x = x; this.y = y; this.owner = owner;
            this.width = 4; this.height = 10; this.isAlive = true;
            this.dx = dx; this.dy = dy;
        }
        update() { this.x += this.dx; this.y += this.dy; }
        draw(ctx) {
            ctx.fillStyle = this.owner === 'player' ? '#00ff00' : '#ff0000';
            ctx.fillRect(this.x - this.width/2, this.y, this.width, this.height);
        }
    }
    class Laser {
        constructor(x, y, canvasWidth, lifespan) {
            this.x = x;
            this.y = y;
            this.width = 10;
            this.lifespan = lifespan;
            this.isAlive = true;
            this.initialLifespan = lifespan;
            this.laserX = 0; // Position relative to boss
            this.laserDirection = Math.random() < 0.5 ? 1 : -1;
            this.laserSpeed = canvasWidth / lifespan;
        }

        update() {
            this.lifespan--;
            this.laserX += this.laserDirection * this.laserSpeed;
            if(this.lifespan <= 0) this.isAlive = false;
        }

        draw(ctx, bossX) {
            const alpha = Math.min(1, (this.initialLifespan - this.lifespan) / 30);
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = '#ff5555';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 15;
            ctx.fillRect(bossX + this.laserX - (this.width / 2), this.y, this.width, 1000);
            ctx.restore();
        }
    }
    class Particle {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.size = Math.random() * 3 + 1;
            this.speedX = Math.random() * 3 - 1.5;
            this.speedY = Math.random() * 3 - 1.5;
            this.lifespan = 100;
            this.color = `hsl(${Math.random() * 60 + 20}, 100%, 50%)`;
        }
        update() { this.x += this.speedX; this.y += this.speedY; this.lifespan--; }
        draw(ctx) {
            ctx.fillStyle = this.color;
            ctx.globalAlpha = this.lifespan / 100;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }
    
    class FloatingText {
        constructor(x, y, text, color = '#ffff00') {
            this.x = x;
            this.y = y;
            this.text = text;
            this.color = color;
            this.lifespan = 60; // 60 frames, approx 1 second
            this.opacity = 1;
            this.speedY = -1;
        }

        update() {
            this.y += this.speedY;
            this.lifespan--;
            if (this.lifespan < 30) {
                this.opacity = this.lifespan / 30;
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.opacity;
            ctx.fillStyle = this.color;
            ctx.font = "0.8rem 'Press Start 2P'";
            ctx.textAlign = 'center';
            ctx.fillText(this.text, this.x, this.y);
            ctx.restore();
        }
    }

    class PowerUp {
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.type = type; // 'shield', 'bomb', atau 'bullet'
            this.size = 25;
            this.speedY = 2;
            this.isAlive = true;
        }
        update() {
            this.y += this.speedY;
        }
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            
            let text = '';
            if (this.type === 'shield') {
                ctx.fillStyle = 'rgba(0, 150, 255, 0.8)';
                text = 'S';
            } else if (this.type === 'bomb') {
                ctx.fillStyle = 'rgba(255, 200, 0, 0.8)';
                text = 'B';
            } else if (this.type === 'bullet') {
                ctx.fillStyle = 'rgba(255, 100, 0, 0.8)';
                text = 'P'; // Peluru
            }

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.font = `${this.size * 0.6}px 'Press Start 2P'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 0, 2);

            ctx.restore();
        }
    }
    
    class BackgroundManager {
        constructor(canvasWidth, canvasHeight) {
            this.canvasWidth = canvasWidth;
            this.canvasHeight = canvasHeight;
            this.stars = [];
            this.planets = [];
            this.asteroids = [];
            this.planetColors = ['#1A0E2A', '#2C183E', '#3D2252', '#361A29', '#52283E', '#1A2233', '#292E47'];
            this.init();
        }

        init() {
            for (let i = 0; i < 100; i++) {
                this.stars.push({
                    x: Math.random() * this.canvasWidth,
                    y: Math.random() * this.canvasHeight,
                    size: Math.random() * 1.5 + 0.5,
                    speed: Math.random() * 0.2 + 0.1
                });
            }

            for (let i = 0; i < 3; i++) {
                this.planets.push({
                    x: Math.random() * this.canvasWidth,
                    y: Math.random() * (this.canvasHeight - 100),
                    size: Math.random() * 40 + 20,
                    color: this.planetColors[Math.floor(Math.random() * this.planetColors.length)],
                    speed: Math.random() * 0.2 + 0.1
                });
            }
            for (let i = 0; i < 20; i++) {
                this.asteroids.push({
                    x: Math.random() * this.canvasWidth,
                    y: Math.random() * this.canvasHeight,
                    size: Math.random() * 4 + 1,
                    color: '#444',
                    speed: Math.random() * 0.6 + 0.4
                });
            }
        }

        update() {
            const updateLayer = (layer) => {
                layer.forEach(item => {
                    item.y += item.speed;
                    if (item.y > this.canvasHeight + item.size) {
                        item.y = -item.size;
                        item.x = Math.random() * this.canvasWidth;
                    }
                });
            };
            updateLayer(this.stars);
            updateLayer(this.planets);
            updateLayer(this.asteroids);
        }

        draw(ctx) {
            ctx.fillStyle = '#fff';
            this.stars.forEach(s => {
                ctx.globalAlpha = s.size / 2;
                ctx.fillRect(s.x, s.y, s.size, s.size);
            });
            ctx.globalAlpha = 1;

            this.planets.forEach(p => {
                ctx.save();
                ctx.shadowBlur = 25;
                ctx.shadowColor = p.color;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
            this.asteroids.forEach(a => {
                ctx.fillStyle = a.color;
                ctx.fillRect(a.x, a.y, a.size, a.size);
            });
        }
    }

    class WaveManager {
        constructor(game) {
            this.game = game;
            this.waveTimer = 3000;
            this.waveCooldown = 5000;
            this.patterns = [this.spawnLine, this.spawnV, this.spawnSides];
        }

        update(deltaTime) {
            if (this.game.isBossActive && this.game.stage < 4) return;
            this.waveTimer -= deltaTime;
            if (this.waveTimer <= 0) {
                const dualSpawnChance = Math.min(0.05 + 0.05 * this.game.stage, 0.5); 
                if (Math.random() < dualSpawnChance) {
                    let pattern1Index = Math.floor(Math.random() * this.patterns.length);
                    let pattern2Index = Math.floor(Math.random() * this.patterns.length);
                    if (this.patterns.length > 1) {
                        while (pattern2Index === pattern1Index) {
                            pattern2Index = Math.floor(Math.random() * this.patterns.length);
                        }
                    }
                    this.patterns[pattern1Index].call(this, this.game);
                    setTimeout(() => {
                        this.patterns[pattern2Index].call(this, this.game);
                    }, 500);
                    this.waveTimer = Math.max(1500, (this.waveCooldown * 1.5) - (this.game.stage * 200));
                } else {
                    const pattern = this.patterns[Math.floor(Math.random() * this.patterns.length)];
                    pattern.call(this, this.game);
                    this.waveTimer = Math.max(1000, this.waveCooldown - (this.game.stage * 200));
                }
            }
        }
        
        spawnSquad(game, enemyType, count, patternLogic) {
            game.squadCounter++;
            const squadId = game.squadCounter;
            for (let i = 0; i < count; i++) {
                const enemy = new Enemy(enemyTypes[enemyType], 0, 0, game); 
                enemy.squadId = squadId;
                patternLogic(enemy, i, count, game);
                game.enemies.push(enemy);
            }
        }

        spawnLine(game) {
            const enemyType = Math.random() < 0.7 ? 'drone' : 'fighter';
            const count = 5 + Math.floor(game.stage / 2);
            this.spawnSquad(game, enemyType, count, (enemy, i, count, game) => {
                enemy.x = (game.canvas.width / 10) + i * (game.canvas.width * 0.8 / (count-1));
                enemy.y = -50;
                enemy.pattern = (e) => { e.y += 2 * (1 + game.stage * 0.15); };
            });
        }

        spawnV(game) {
            const enemyType = 'fighter';
            const count = 5;
            this.spawnSquad(game, enemyType, count, (enemy, i, count, game) => {
                const index = i - 2;
                enemy.x = game.canvas.width / 2 + index * 40;
                enemy.y = -50 - Math.abs(index) * 30;
                enemy.pattern = (e) => { e.y += 2.5 * (1 + game.stage * 0.15); };
            });
        }

        spawnSides(game) {
            const enemyType = 'scout';
            const count = 3;
            const startX = Math.random() < 0.5 ? -30 : game.canvas.width + 30;
            const speedX = (startX < 0 ? 3 : -3) * (1 + game.stage * 0.15);
            this.spawnSquad(game, enemyType, count, (enemy, i, count, game) => {
                enemy.x = startX;
                enemy.y = 100 + i * 50;
                enemy.pattern = (e) => { e.x += speedX; e.y += 0.5; };
            });
        }
    }

    class UIManager {
        constructor() {
            this.gameContainer = document.querySelector('.game-container');
            this.mainMenu = document.getElementById('main-menu');
            this.gameArea = document.getElementById('game-area');
            this.gamepadArea = document.getElementById('gamepad-area');
            this.gameOverModal = document.getElementById('game-over-modal');
            this.score = document.getElementById('score');
            this.stage = document.getElementById('stage');
            this.bombs = document.getElementById('bombs');
            this.shipSelection = document.getElementById('ship-selection');
            this.highscoreList = document.getElementById('highscore-list');
            this.gosList1 = document.getElementById('gos-list-1');
            this.gosList2 = document.getElementById('gos-list-2');
            this.newHighscoreEntry = document.getElementById('new-highscore-entry');
            this.gameOverScores = document.getElementById('game-over-scores');
        }
        showMenu() {
            this.gameContainer.classList.remove('game-active-layout');
            document.getElementById('game-board-wrapper').classList.remove('boss-active-bg');
            this.gameArea.style.display = 'none';
            this.gamepadArea.style.display = 'none';
            this.gameOverModal.style.display = 'none';
            this.mainMenu.style.display = 'block';
        }
        showGame(isTouchDevice) {
            this.gameContainer.classList.add('game-active-layout');
            this.mainMenu.style.display = 'none'; 
            this.gameOverModal.style.display = 'none';
            this.gameArea.style.display = 'flex';
            if(isTouchDevice) {
                this.gamepadArea.style.display = 'flex';
            }
        }
        updateBombs(count) {
            this.bombs.textContent = `üí£: ${count}`;
        }
        displayHighScores(scores, { list1, list2 = null, limit = 3, showMedals = false }) {
            const medals = ['ü•á', 'ü•à', 'ü•â'];
            if(scores.length === 0){
                list1.innerHTML = '<li>Memuatkan...</li>';
                if(list2) list2.innerHTML = '';
                return;
            }
            if (list2) {
                list1.innerHTML = scores.slice(0, 5).map((s, i) => `<li><div>${i + 1}. ${s.name}</div><span>${s.score}</span></li>`).join('');
                list2.innerHTML = scores.slice(5, 10).map((s, i) => `<li><div>${i + 6}. ${s.name}</div><span>${s.score}</span></li>`).join('');
            } else {
                list1.innerHTML = scores.slice(0, limit).map((s, i) => {
                    const medal = showMedals ? medals[i] || '' : '';
                    return `<li><div>${medal} ${s.name}</div><span>${s.score}</span></li>`;
                }).join('');
            }
        }
    }
    
    class ScoreManager {
        constructor() { this.scores = []; }
        getScores() { return this.scores; }
        async saveUserScore(db, userId, name, score) {
            if (!db || !userId) return;
            try {
                const scoreRef = window.firebase.doc(db, 'games/galaga/highscores', userId);
                const docSnap = await window.firebase.getDoc(scoreRef);
                if (docSnap.exists() && docSnap.data().score >= score) return;
                await window.firebase.setDoc(scoreRef, { name, score, timestamp: new Date() });
            } catch (error) { console.error("Ralat menyimpan markah:", error); }
        }
        async loadGlobalScores(db) {
            if (!db) {
                this.scores = [];
                return;
            }
            try {
                const q = window.firebase.query(window.firebase.collection(db, "games/galaga/highscores"), window.firebase.orderBy("score", "desc"), window.firebase.limit(10));
                const querySnapshot = await window.firebase.getDocs(q);
                const firebaseScores = [];
                querySnapshot.forEach((doc) => firebaseScores.push(doc.data()));
                this.scores = firebaseScores;
            } catch (error) { 
                console.error("Ralat memuatkan markah:", error); 
                this.scores = [];
            }
        }
        isHighScore(score) {
            if (score <= 0) return false;
            if (this.scores.length < 10) return true;
            return score > this.scores[this.scores.length - 1].score;
        }
    }

    class Game {
        constructor() {
            this.canvas = document.getElementById('game-canvas');
            this.ctx = this.canvas.getContext('2d');
            this.uiManager = new UIManager();
            this.scoreManager = new ScoreManager();
            this.backgroundManager = null; 
            document.getElementById('game-version').textContent = `v${GAME_VERSION}`;
            this.gameState = 'menu'; 
            this.keys = {}; 
            this.player = null; 
            this.enemies = []; 
            this.projectiles = []; 
            this.lasers = [];
            this.particles = [];
            this.powerUps = [];
            this.floatingTexts = [];
            this.squadCounter = 0;
            this.stage = 1; 
            this.score = 0; 
            this.scoreAtStageStart = 0;
            this.waveManager = new WaveManager(this);
            this.stageTimer = 45000; 
            this.isBossActive = false;
            this.lastTime = 0; 
            this.gameLoopAnimation = null;
            this.touchDx = 0; 
            this.touchDy = 0; 
            this.isTouchFiring = false; 
            this.isSpecialAttackPressed = false;
            this.screenShakeIntensity = 0;
            this.screenFlashAlpha = 0;
            this.db = null;
            this.auth = null;
            this.userId = null;

            this.setupShipSelection(); 
            this.setupEventListeners();
            this.initializeFirebase();
        }
        
        setupShipSelection() {
            const container = this.uiManager.shipSelection;
            const statsDisplay = document.getElementById('ship-stats-display');
            container.innerHTML = '';
            
            const updateStats = (shipId) => {
                const stats = shipStats[shipId];
                const fireRateValue = (400 - stats.fireRate) / 250; 
                const bulletValue = (stats.bulletCount - 1) / (stats.maxBulletCount - 1);

                statsDisplay.innerHTML = `
                    <div class="stat-item">
                        <span>Perisai:</span>
                        <span>${'‚ù§Ô∏è'.repeat(stats.hp)}</span>
                    </div>
                    <div class="stat-item">
                        <span>Bom:</span>
                        <span>${'üí£'.repeat(stats.startingBombs)}</span>
                    </div>
                    <div class="stat-item">
                        <span>Tembakan:</span>
                        <div class="stat-bar-container">
                            <div class="stat-bar" style="width: ${fireRateValue * 100}%"></div>
                        </div>
                    </div>
                     <div class="stat-item">
                        <span>Peluru:</span>
                         <div class="stat-bar-container">
                            <div class="stat-bar" style="width: ${bulletValue * 100}%"></div>
                        </div>
                    </div>
                `;
            };

            let isFirst = true;
            for (const configId in playerConfigs) {
                const config = playerConfigs[configId];
                const button = document.createElement('button');
                button.dataset.configId = configId;
                const img = document.createElement('img');
                img.src = shipImageUrls[configId];
                img.alt = config.name;
                const nameLabel = document.createElement('p');
                nameLabel.textContent = config.name;
                button.appendChild(img);
                button.appendChild(nameLabel);
                if (isFirst) {
                    button.classList.add('active');
                    updateStats(configId);
                    isFirst = false;
                }
                button.addEventListener('click', () => {
                    container.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    updateStats(configId);
                });
                container.appendChild(button);
            }
        }
        
        async initializeFirebase() {
            try {
                const app = window.firebase.initializeApp(firebaseConfig);
                this.db = window.firebase.getFirestore(app);
                this.auth = window.firebase.getAuth(app);
                await window.firebase.signInAnonymously(this.auth);
                this.userId = this.auth.currentUser.uid;
                this.refreshHighScores();
            } catch (error) {
                console.error("Gagal memulakan Firebase:", error);
                this.uiManager.displayHighScores([], { list1: this.uiManager.highscoreList, limit: 3, showMedals: true });
            }
        }
        
        setupEventListeners() {
            window.addEventListener('keydown', (e) => this.keys[e.key] = true);
            window.addEventListener('keyup', (e) => this.keys[e.key] = false);

            document.getElementById('start-game-button').addEventListener('click', () => this.start());
            document.getElementById('main-menu-button').addEventListener('click', () => { 
                this.gameState = 'menu';
                this.uiManager.showMenu();
            });
            document.getElementById('continue-button').addEventListener('click', () => this.continueGame());
            document.getElementById('save-score-button').addEventListener('click', async () => {
                const name = document.getElementById('player-name').value.trim().toUpperCase() || 'PLAYER';
                await this.scoreManager.saveUserScore(this.db, this.userId, name, this.score);
                this.uiManager.newHighscoreEntry.style.display = 'none';
                this.uiManager.gameOverScores.style.display = 'block';
                await this.refreshHighScores(true); 
            });
            document.getElementById('refresh-scores-button').addEventListener('click', () => this.refreshHighScores());
            
            document.getElementById('toggle-instructions-button').addEventListener('click', () => {
                const instructions = document.getElementById('instructions');
                const button = document.getElementById('toggle-instructions-button');
                const isHidden = instructions.style.display === 'none';
                instructions.style.display = isHidden ? 'block' : 'none';
                button.textContent = isHidden ? 'SEMBUNYI ARAHAN' : 'TUNJUK ARAHAN';
            });

            const joystickArea = document.getElementById('joystick-area');
            const joystickHandle = document.getElementById('joystick-handle');
            const fireButton = document.getElementById('fire-button');
            const specialAttackButton = document.getElementById('special-attack-button');
            let joystickTouchId = null;
            let joystickCenter = { x: 0, y: 0 };

            joystickArea.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (joystickTouchId === null) {
                    joystickTouchId = e.changedTouches[0].identifier;
                    joystickCenter = { x: joystickArea.offsetWidth / 2, y: joystickArea.offsetHeight / 2 };
                }
            }, { passive: false });
            joystickArea.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickTouchId) {
                        const touch = e.changedTouches[i];
                        const rect = joystickArea.getBoundingClientRect();
                        let x = touch.clientX - rect.left;
                        let y = touch.clientY - rect.top;
                        let dx = x - joystickCenter.x;
                        let dy = y - joystickCenter.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const maxDistance = joystickArea.offsetWidth / 2;
                        if (distance > maxDistance) {
                            dx = (dx / distance) * maxDistance;
                            dy = (dy / distance) * maxDistance;
                        }
                        joystickHandle.style.transform = `translate(${dx}px, ${dy}px)`;
                        this.touchDx = dx / maxDistance;
                        this.touchDy = dy / maxDistance;
                    }
                }
            }, { passive: false });
            const resetJoystick = () => {
                joystickTouchId = null;
                joystickHandle.style.transform = `translate(0px, 0px)`;
                this.touchDx = 0;
                this.touchDy = 0;
            };
            joystickArea.addEventListener('touchend', resetJoystick);
            joystickArea.addEventListener('touchcancel', resetJoystick);
            fireButton.addEventListener('touchstart', (e) => { e.preventDefault(); this.isTouchFiring = true; }, { passive: false });
            fireButton.addEventListener('touchend', (e) => { e.preventDefault(); this.isTouchFiring = false; }, { passive: false });
            specialAttackButton.addEventListener('touchstart', (e) => { e.preventDefault(); this.isSpecialAttackPressed = true; }, { passive: false });
            specialAttackButton.addEventListener('touchend', (e) => { e.preventDefault(); this.isSpecialAttackPressed = false; }, { passive: false });
        }

        async refreshHighScores(isGameOver = false) {
            await this.scoreManager.loadGlobalScores(this.db);
            const scores = this.scoreManager.getScores();
            if (isGameOver) {
                this.uiManager.displayHighScores(scores, { list1: this.uiManager.gosList1, list2: this.uiManager.gosList2, limit: 10 });
            } else {
                this.uiManager.displayHighScores(scores, { list1: this.uiManager.highscoreList, limit: 3, showMedals: true });
            }
        }

        start(isContinuing = false) {
            this.gameState = 'playing';
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            this.uiManager.showGame(isTouchDevice);
            
            this.canvas.width = this.canvas.offsetWidth;
            this.canvas.height = this.canvas.offsetHeight;

            this.backgroundManager = new BackgroundManager(this.canvas.width, this.canvas.height);

            if (!isContinuing) {
                this.stage = 1;
                this.score = 0;
            } else {
                this.score = 0;
            }
            const selectedConfigId = this.uiManager.shipSelection.querySelector('button.active').dataset.configId;
            const stats = shipStats[selectedConfigId];
            this.player = new Player(playerConfigs[selectedConfigId], stats, this.canvas.width, this.canvas.height);
            this.enemies = []; this.projectiles = []; this.particles = []; this.powerUps = []; this.floatingTexts = []; this.lasers = [];
            this.squadCounter = 0;

            this.scoreAtStageStart = this.score;
            this.isBossActive = false;
            this.stageTimer = 45000;
            this.lastTime = performance.now();
            if (!this.gameLoopAnimation) {
                 this.gameLoop(this.lastTime);
            }
        }
        
        continueGame() { this.start(true); }

        async gameOver() {
            this.gameState = 'gameover';
            this.screenShakeIntensity = 0;
            document.getElementById('game-board-wrapper').classList.remove('boss-active-bg');
            await this.refreshHighScores(true);
            setTimeout(() => {
                if (this.gameState === 'gameover') {
                    this.uiManager.gameOverModal.style.display = 'flex';
                    if(this.scoreManager.isHighScore(this.score)) {
                        this.uiManager.newHighscoreEntry.style.display = 'block';
                        this.uiManager.gameOverScores.style.display = 'none';
                    } else {
                        this.uiManager.newHighscoreEntry.style.display = 'none';
                        this.uiManager.gameOverScores.style.display = 'block';
                    }
                }
            }, 1500);
        }
        
        gameLoop(timestamp) {
            if (this.gameState !== 'playing') {
                cancelAnimationFrame(this.gameLoopAnimation);
                this.gameLoopAnimation = null;
                return;
            };
            const deltaTime = Math.min(timestamp - this.lastTime, 100);
            this.lastTime = timestamp;
            this.update(deltaTime, timestamp);
            this.draw(timestamp);
            this.gameLoopAnimation = requestAnimationFrame((t) => this.gameLoop(t));
        }

        checkCollisions() {
            this.projectiles.forEach((p) => {
                if (!p.isAlive) return;
                if (p.owner === 'player') {
                    this.enemies.forEach((e) => {
                        if (!e.isAlive) return;
                        const dist = Math.hypot(p.x - e.x, p.y - e.y);
                        if (dist < e.size / 2 + 5) {
                            p.isAlive = false;
                            e.hp--;
                            if (e.hp <= 0) {
                                e.isAlive = false;
                                this.score += (e instanceof Boss) ? 1000 : 100;
                                this.createExplosion(e.x, e.y, 15);
                                this.checkSquadWiped(e.squadId, e.x, e.y);
                                if (e instanceof Boss) { setTimeout(() => this.nextStage(), 2000); }
                            } else { this.createExplosion(p.x, p.y, 5); }
                        }
                    });
                } else { 
                    if (this.player.isAlive) {
                        const dist = Math.hypot(p.x - this.player.x, p.y - this.player.y);
                        if (dist < this.player.size / 3) { 
                            p.isAlive = false; 
                            this.player.takeDamage();
                        }
                    }
                }
            });
            this.lasers.forEach(laser => {
                if (!laser.isAlive || !this.player.isAlive) return;
                const boss = this.enemies.find(e => e instanceof Boss);
                if (boss) {
                    const laserRect = {
                        x: boss.x + laser.laserX - laser.width / 2,
                        y: laser.y,
                        width: laser.width,
                        height: this.canvas.height - laser.y
                    };
                    const playerRect = {
                        x: this.player.x - this.player.size / 3,
                        y: this.player.y - this.player.size / 3,
                        width: this.player.size * 2/3,
                        height: this.player.size * 2/3
                    };
                    if (laserRect.x < playerRect.x + playerRect.width &&
                        laserRect.x + laserRect.width > playerRect.x &&
                        laserRect.y < playerRect.y + playerRect.height &&
                        laserRect.y + laserRect.height > playerRect.y) {
                            this.player.takeDamage();
                    }
                }
            });
            this.enemies.forEach(e => {
                if (!e.isAlive || !this.player.isAlive) return;
                const dist = Math.hypot(this.player.x - e.x, this.player.y - e.y);
                if (dist < (this.player.size / 3 + e.size / 3)) {
                    this.player.takeDamage();
                    e.isAlive = false;
                    this.createExplosion(e.x, e.y, 15);
                }
            });
            this.powerUps.forEach(pu => {
                if(!pu.isAlive || !this.player.isAlive) return;
                const dist = Math.hypot(this.player.x - pu.x, this.player.y - pu.y);
                if (dist < this.player.size / 2 + pu.size / 2) {
                    if(pu.type === 'shield') this.player.addShield();
                    else if (pu.type === 'bomb') this.player.addBombs();
                    else if (pu.type === 'bullet') this.player.addBullet();
                    pu.isAlive = false;
                }
            });
        }

        createExplosion(x, y, count) {
            for (let i = 0; i < count; i++) { this.particles.push(new Particle(x, y)); }
        }
        
        checkSquadWiped(squadId, x, y) {
            if (squadId === null || squadId === undefined) return;
            const squadMatesAlive = this.enemies.some(enemy => enemy.squadId === squadId && enemy.isAlive);
            if (!squadMatesAlive) {
                const bonusScore = 500;
                this.score += bonusScore;
                this.floatingTexts.push(new FloatingText(x, y, `+${bonusScore}`));
                this.tryDropPowerUp(x, y);
            }
        }

        tryDropPowerUp(x, y) {
            const dropTypes = ['shield', 'bomb', 'bullet'];
            const dropType = dropTypes[Math.floor(Math.random() * dropTypes.length)];
            this.powerUps.push(new PowerUp(x, y, dropType));
        }
        
        triggerSpecialAttack() {
            this.screenFlashAlpha = 1.0;
            this.enemies.forEach(e => {
                if (e.isAlive) {
                    e.hp -= 5;
                    if (e.hp <= 0) {
                        e.isAlive = false;
                        this.score += (e instanceof Boss) ? 1000 : 100;
                        this.createExplosion(e.x, e.y, 15);
                        if (e instanceof Boss) { setTimeout(() => this.nextStage(), 2000); }
                    }
                }
            });
        }
        
        update(deltaTime, timestamp) {
            if (this.player && this.gameState === 'playing') {
                this.player.update(this.keys, this.touchDx, this.touchDy);
                if (this.keys[' '] || this.isTouchFiring) {
                    const newProjectiles = this.player.shoot();
                    if (newProjectiles) {
                        this.projectiles.push(...newProjectiles);
                    }
                }
                if(this.keys['b'] || this.isSpecialAttackPressed) {
                    if(this.player.useBomb(this)) {
                        this.keys['b'] = false;
                        this.isSpecialAttackPressed = false;
                    }
                }
            }
            this.projectiles.forEach(p => p.update());
            this.lasers.forEach(l => l.update());
            this.particles.forEach(p => p.update());
            this.powerUps.forEach(p => p.update());
            this.floatingTexts.forEach(ft => ft.update());
            if (this.backgroundManager) this.backgroundManager.update();
            
            if (this.gameState === 'playing' && !this.isBossActive && deltaTime > 0) {
                this.stageTimer -= deltaTime;
                if (this.stageTimer <= 0) { this.spawnBoss(); }
            }
            if (this.gameState === 'playing') { this.waveManager.update(deltaTime || 0); }
            this.enemies.forEach(e => e.update(this.player, this));
            
            if(this.player && this.player.isAlive) this.checkCollisions();
            
            if (this.player && !this.player.isAlive && this.gameState !== 'gameover') {
                 this.createExplosion(this.player.x, this.player.y, 30);
                 this.gameOver();
            }

            this.enemies = this.enemies.filter(e => e.isAlive && e.y < this.canvas.height + e.size && e.x > -e.size && e.x < this.canvas.width + e.size);
            this.projectiles = this.projectiles.filter(p => p.isAlive && p.y > -p.height && p.y < this.canvas.height);
            this.lasers = this.lasers.filter(l => l.isAlive);
            this.particles = this.particles.filter(p => p.lifespan > 0);
            this.powerUps = this.powerUps.filter(p => p.isAlive && p.y < this.canvas.height + p.size);
            this.floatingTexts = this.floatingTexts.filter(ft => ft.lifespan > 0);
            
            this.uiManager.score.textContent = `SKOR: ${this.score}`;
            this.uiManager.stage.textContent = `PERINGKAT: ${this.stage}`;
            if(this.player) this.uiManager.updateBombs(this.player.bombs);
            
            if (this.screenFlashAlpha > 0) {
                this.screenFlashAlpha -= 0.05;
            }
        }

        draw(timestamp) {
            this.ctx.save();
            if (this.screenShakeIntensity > 0) {
                const dx = Math.random() * this.screenShakeIntensity - this.screenShakeIntensity / 2;
                const dy = Math.random() * this.screenShakeIntensity - this.screenShakeIntensity / 2;
                this.ctx.translate(dx, dy);
            }
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
            if (this.backgroundManager) this.backgroundManager.draw(this.ctx);

            if(this.player && this.player.isAlive) {
                this.player.drawShield(this.ctx);
                this.player.draw(this.ctx, timestamp / 100);
            }
            this.projectiles.forEach(p => p.draw(this.ctx));
            const boss = this.enemies.find(e => e instanceof Boss);
            this.lasers.forEach(l => l.draw(this.ctx, boss ? boss.x : 0));
            this.enemies.forEach(e => e.draw(this.ctx, timestamp / 100));
            this.particles.forEach(p => p.draw(this.ctx));
            this.powerUps.forEach(p => p.draw(this.ctx));
            this.floatingTexts.forEach(ft => ft.draw(this.ctx));

            if (this.screenFlashAlpha > 0) {
                this.ctx.fillStyle = `rgba(255, 255, 255, ${this.screenFlashAlpha})`;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            this.ctx.restore();
        }

        spawnBoss() {
            this.isBossActive = true;
            document.getElementById('game-board-wrapper').classList.add('boss-active-bg');
            this.screenShakeIntensity = 3;
            
            const bossConfig = bossConfigs[(this.stage - 1) % bossConfigs.length];
            const boss = new Boss(bossConfig, this.canvas.width / 2, -100, this);
            
            const baseHp = 200;
            const additionalHp = (this.stage - 1) * 100;
            boss.hp = baseHp + additionalHp;
            
            if (bossConfig.id === 'boss-titan') {
                boss.entryCompleteTime = null; 
                boss.pattern = (e) => { 
                    if (e.y < 100) { e.y += 1; } 
                    else {
                        if (e.entryCompleteTime === null) { e.entryCompleteTime = e.age; }
                        const timeSinceEntry = e.age - e.entryCompleteTime;
                        e.x = e.initialX + Math.sin(timeSinceEntry / 80) * (this.canvas.width / 2 - e.size / 2 - 20);
                    }
                };
            } else if (bossConfig.id === 'boss-viper') {
                 boss.pattern = (e) => { 
                    if (e.y < 120) { e.y += 1.5; } 
                    else {
                        e.x = e.initialX + Math.cos(e.age / 50) * (this.canvas.width / 2 - e.size / 2 - 10);
                    }
                };
            } else if (bossConfig.id === 'boss-serpent') {
                boss.pattern = (e) => { 
                    if (e.y < 80) { e.y += 0.5; } 
                    e.x = e.initialX + Math.sin(e.age / 40) * 100;
                    e.config.parts.body1.y = -15 + Math.sin(e.age / 10) * 5;
                    e.config.parts.body2.y = 15 + Math.cos(e.age / 10) * 5;
                    e.config.parts.body3.y = 40 + Math.sin(e.age / 10) * 5;
                };
            }
            this.enemies.push(boss);
        }

        nextStage() {
            if (!this.isBossActive) return;
            this.stage++;
            this.score += 1000;
            this.scoreAtStageStart = this.score;
            this.isBossActive = false;
            this.screenShakeIntensity = 0;
            document.getElementById('game-board-wrapper').classList.remove('boss-active-bg');
            this.stageTimer = 45000;
            this.waveManager.waveTimer = 3000;
        }
    }
    
    new Game();
});
</script>

</body>
</html>

