<!DOCTYPE html>
<html lang="ms">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Permainan Tembakan Angkasa</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #000;
            color: #fff;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }
        .game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100vh;
        }
        .main-menu-wrapper {
            padding: 20px;
            background-color: #1a1a1a;
            border: 2px solid #00ff00;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 255, 0, 0.2);
            text-align: center;
            /* PENAMBAHBAIKAN: Had lebar dikurangkan */
            max-width: 640px;
            width: 90%;
        }

        .game-container.game-active-layout {
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 0;
            /* PENAMBAHBAIKAN: Had lebar dikurangkan */
            max-width: 640px; 
            margin: 0 auto;
        }
        #game-area {
            flex: 2.5; 
            position: relative;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
        }
        #gamepad-area {
            flex: 1; 
            background-color: #111;
            border-top: 4px solid #00ff00;
            display: none; /* Disembunyikan secara lalai, dikawal oleh JS */
            justify-content: space-between;
            align-items: center;
            padding: 10px 30px;
            box-sizing: border-box;
            width: 100%;
        }
        
        #game-board-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }
        #game-canvas {
            width: 100%;
            height: 100%;
            background-color: #000;
            background-image: radial-gradient(white 0.5px, transparent 0.5px), radial-gradient(white 0.5px, transparent 0.5px);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
            animation: scroll-background 20s linear infinite;
        }
        @keyframes scroll-background {
            from { background-position-y: 0px; }
            to { background-position-y: 100%; }
        }
        
        h1, h2, h3 { color: #00ff00; font-family: 'Press Start 2P', cursive; }

        #ship-selection { display: flex; gap: 20px; justify-content: center; align-items: center; margin-bottom: 20px; }
        #ship-selection button { background: none; border: 2px solid transparent; border-radius: 8px; padding: 10px; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 5px; }
        #ship-selection img { width: 80px; height: 80px; object-fit: contain; }
        #ship-selection p { margin: 0; font-size: 0.7rem; color: #ccc; }
        #ship-selection button.active { border-color: #00ff00; background-color: rgba(0, 255, 0, 0.1); }
        #ship-selection button.active p { color: #00ff00; }
        #start-game-button { background-color: #00ff00; color: #000; font-size: 1rem; padding: 15px 30px; margin-top: 15px; border: none; border-radius: 4px; cursor: pointer;}
        
        #ui-layer { position: absolute; top: 10px; left: 10px; right: 10px; display: flex; justify-content: space-between; font-size: 1rem; z-index: 10; pointer-events: none; text-shadow: 2px 2px #000; }
        #player-stats { display: flex; gap: 20px; }
        
        #game-board-wrapper.boss-active-bg #game-canvas { animation-duration: 5s; }
        #game-board-wrapper.boss-active-bg::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(ellipse at center, rgba(255,0,0,0.4) 0%,rgba(255,0,0,0) 70%); z-index: 5; pointer-events: none; animation: pulse-red 2s infinite; }
        @keyframes pulse-red { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: none; justify-content: center; align-items: center; z-index: 100; }
        .modal-content { color: #fff; background-color: rgba(26, 26, 26, 0.9); padding: 30px; border-radius: 15px; border: 4px solid #555; text-align: center; box-shadow: 0 0 20px rgba(0,0,0,0.8); }
        .modal-content h2 { margin-top: 0; font-size: 1.8rem; color: #ff4136;}
        .modal-content button { padding: 10px 20px; margin: 5px; border: 1px solid #555; border-radius: 4px; background-color: #444; color: white; cursor: pointer; font-family: 'Press Start 2P', cursive; font-size: 0.8rem; }
        .modal-content input { background-color: #333; border: 2px solid #00ff00; color: #f0f0f0; padding: 8px; font-family: 'Press Start 2P', cursive; text-align: center; width: 200px; text-transform: uppercase; }

        #highscore-container { text-align: center; width: 100%; font-size: 0.7rem; margin-top: 20px;}
        #highscore-container h3 { margin-top: 0; margin-bottom: 15px; color: #ffff00; display: inline-block; margin-right: 10px;}
        #refresh-scores-button { background: none; border: none; font-size: 1rem; cursor: pointer; color: #fff; }
        .highscore-list ol, .highscore-columns-shared ol { list-style-type: none; padding-left: 0; margin: 0; text-align: left; }
        .highscore-list ol { min-width: 250px; }
        .highscore-columns-shared { display: flex; justify-content: center; gap: 40px; }
        .highscore-columns-shared ol { min-width: 170px; }
        .highscore-list li, .highscore-columns-shared li { margin-bottom: 8px; color: #f0f0f0; }
        .highscore-list li span, .highscore-columns-shared li span { color: #ffff00; float: right; }

        #joystick-area { width: 120px; height: 120px; background-color: rgba(255, 255, 255, 0.1); border-radius: 50%; position: relative; }
        #joystick-handle { width: 60px; height: 60px; background-color: rgba(255, 255, 255, 0.3); border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 50%; position: absolute; top: 30px; left: 30px; }
        #action-buttons { display: flex; align-items: center; gap: 20px; }
        .action-button { width: 80px; height: 80px; border-radius: 50%; color: white; font-size: 2rem; display: flex; justify-content: center; align-items: center; border: 2px solid; }
        #fire-button { background-color: rgba(255, 0, 0, 0.3); border-color: rgba(255, 0, 0, 0.6); }
        #special-attack-button { background-color: rgba(0, 100, 255, 0.3); border-color: rgba(0, 100, 255, 0.6); }
        
        /* Menu Arahan */
        #toggle-instructions-button {
            background-color: transparent;
            border: 2px solid #555;
            color: #ccc;
            padding: 8px 15px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            cursor: pointer;
            border-radius: 4px;
            margin-top: 30px;
        }
        #toggle-instructions-button:hover { background-color: #333; }
        #instructions {
            border: 2px solid #555;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            text-align: left;
            font-size: 0.7rem;
            line-height: 1.5;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }
        #instructions h3 { margin-top: 0; text-align: center;}
        #instructions span { color: #ffff00; }

    </style>
</head>
<body>

    <div class="game-container">
        <div id="main-menu" class="main-menu-wrapper">
            <h1>TEMBAKAN ANGKASA</h1>
            <p id="game-version"></p>
            <h2>PILIH KAPAL</h2>
            <div id="ship-selection"></div>
            <button id="start-game-button">MULA</button>
            <button id="toggle-instructions-button">TUNJUK ARAHAN</button>
            <div id="instructions" style="display: none;">
                <h3>ARAHAN</h3>
                <b>Papan Kekunci:</b><br>
                <span>Anak Panah/WASD:</span> Bergerak<br>
                <span>Spacebar:</span> Tembak<br>
                <span>B:</span> Serangan Istimewa<br>
                <b>Skrin Sentuh:</b><br>
                <span>Joystick Kiri:</span> Bergerak<br>
                <span>Butang Merah:</span> Tembak<br>
                <span>Butang Biru:</span> Serangan Istimewa
            </div>
            <div id="highscore-container">
                <h3>MARKAH TERTINGGI</h3><button id="refresh-scores-button" disabled>ðŸ”„</button>
                <div class="highscore-list">
                    <ol id="highscore-list"></ol>
                </div>
            </div>
        </div>
        
        <div id="game-area" style="display: none;">
            <div id="game-board-wrapper">
                 <canvas id="game-canvas"></canvas>
                 <div id="ui-layer">
                     <div id="player-stats">
                        <span id="score">SKOR: 0</span>
                        <span id="bombs">ðŸ’£: 0</span>
                     </div>
                     <span id="stage">PERINGKAT: 1</span>
                 </div>
            </div>
        </div>
        
        <div id="gamepad-area" style="display: none;">
             <div id="joystick-area">
                 <div id="joystick-handle"></div>
             </div>
             <div id="action-buttons">
                <button id="special-attack-button" class="action-button">âœ¨</button>
                <button id="fire-button" class="action-button">ðŸ”¥</button>
             </div>
        </div>

        <div id="game-over-modal" class="modal-overlay">
            <div class="modal-content">
                <h2>PERMAINAN TAMAT</h2>
                <div id="new-highscore-entry" style="display: none;">
                    <p>MARKAH TINGGI BAHARU!</p>
                    <input type="text" id="player-name" maxlength="10" placeholder="MASUKKAN NAMA">
                    <button id="save-score-button">SIMPAN</button>
                </div>
                 <div id="game-over-scores" style="display: none;">
                    <h3>10 MARKAH TERTINGGI</h3>
                    <div class="highscore-columns-shared" id="highscore-columns-gameover">
                        <ol id="gos-list-1"></ol> <ol id="gos-list-2"></ol>
                    </div>
                </div>
                <button id="continue-button">MAIN SEMULA</button>
                <button id="main-menu-button">MENU UTAMA</button>
            </div>
        </div>
    </div>
    
    <script type="module">
       window.firebase = {};
    </script>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const GAME_VERSION = "1.1.1";
    
    // --- KONFIGURASI ASET ---
    const interceptorConfig = { "id": "interceptor", "name": "Interceptor", "type": "Pemain", "drawOrder": [ "engineFlame", "body", "cockpit", "wings" ], "parts": { "body": { "shape": "polygon", "color": "#c0c0c0", "x": 0, "y": 0, "rotation": 0, "points": [ 0, -25, -15, 20, 0, 10, 15, 20 ], "scaleX": 100, "scaleY": 100 }, "cockpit": { "shape": "polygon", "color": "#4d94ff", "x": 0, "y": -5, "rotation": 0, "points": [ 0, -15, -8, 5, 8, 5 ], "scaleX": 67, "scaleY": 100 }, "wings": { "shape": "polygon", "color": "#a0a0a0", "x": 0, "y": 13, "rotation": 0, "points": [ -25, 0, 25, 0, 0, -10 ], "scaleX": 126, "scaleY": 118 }, "engineFlame": { "shape": "polygon", "color": "#ffcc00", "x": 0, "y": 16, "rotation": 0, "points": [ -7, 0, 7, 0, 0, 15 ], "scaleX": 100, "scaleY": 100, "animation": { "property": "opacity", "speed": 10, "amplitude": 0.5 } } } };
    const assaultConfig = { "id": "assault", "name": "Assault", "type": "Pemain", "drawOrder": [ "body", "wings", "cockpit", "cannons" ], "parts": { "body": { "shape": "rect", "color": "#808080", "x": 0, "y": 0, "rotation": 0, "width": 49, "height": 49 }, "wings": { "shape": "rect", "color": "#a0a0a0", "x": 0, "y": 0, "rotation": 45, "width": 50, "height": 47 }, "cockpit": { "shape": "rect", "color": "#ff6600", "x": 0, "y": 19, "rotation": 0, "width": 24, "height": 22 }, "cannons": { "shape": "rect", "color": "#666666", "x": 0, "y": -2, "rotation": 89, "width": 53, "height": 5 } } };
    const bomberConfig = { "id": "bomber", "name": "Bomber", "type": "Pemain", "drawOrder": [ "body", "wings", "pods" ], "parts": { "body": { "shape": "rect", "color": "#003300", "x": 0, "y": -1, "rotation": 0, "width": 19, "height": 49 }, "wings": { "shape": "polygon", "color": "#006400", "x": 0, "y": 19, "rotation": 180, "points": [ -40, 0, 40, 0, 20, 10, -20, 10 ], "scaleX": 126, "scaleY": 101 }, "pods": { "shape": "polygon", "color": "#556b2f", "x": 0, "y": -26, "rotation": 0, "points": [ -10, 10, 10, 10, 0, -10 ], "scaleX": 83, "scaleY": 200 } } };
    const droneConfig = { "id": "drone", "name": "Drone", "type": "Musuh", "hp": 1, "drawOrder": [ "body", "eye" ], "parts": { "body": { "shape": "circle", "color": "#4b0082", "x": 0, "y": 0, "rotation": 0, "r": 20 }, "eye": { "shape": "circle", "color": "#ff0000", "x": 0, "y": 8, "rotation": 0, "r": 7, "animation": { "property": "opacity", "speed": 2, "amplitude": 0.5 } } } };
    const fighterConfig = { "id": "fighter", "name": "Fighter", "type": "Musuh", "hp": 2, "drawOrder": [ "body", "cockpit" ], "parts": { "body": { "shape": "polygon", "color": "#8b0000", "x": 0, "y": 0, "rotation": 0, "points": [ 0, -20, -25, 20, 0, 10, 25, 20 ], "scaleX": 140, "scaleY": 115 }, "cockpit": { "shape": "polygon", "color": "#363636", "x": 0, "y": -2, "rotation": 179, "points": [ 0, -10, -5, 5, 5, 5 ], "scaleX": 159, "scaleY": 100 } } };
    const cruiserConfig = { "id": "cruiser", "name": "Cruiser", "type": "Musuh", "hp": 5, "drawOrder": [ "lowerHull", "upperHull", "bridge" ], "parts": { "lowerHull": { "shape": "rect", "color": "#800000", "x": 0, "y": 0, "rotation": 0, "width": 50, "height": 25 }, "upperHull": { "shape": "rect", "color": "#a52a2a", "x": 0, "y": -2, "rotation": 0, "width": 30, "height": 40 }, "bridge": { "shape": "rect", "color": "#ffc0cb", "x": 0, "y": -12, "rotation": 0, "width": 10, "height": 15 } } };
    const scoutConfig = { "id": "scout", "name": "Scout", "type": "Musuh", "hp": 1, "drawOrder": [ "wings", "body" ], "parts": { "body": { "shape": "polygon", "color": "#00ff00", "x": 0, "y": 5, "rotation": 0, "points": [ 0, -15, -10, 10, 10, 10 ], "scaleX": 156, "scaleY": 81 }, "wings": { "shape": "polygon", "color": "#adff2f", "x": 0, "y": 0, "rotation": 0, "points": [ -20, 0, 0, -10, 20, 0, 0, 5 ], "scaleX": 140, "scaleY": 165 } } };
    const kamikazeConfig = { "id": "kamikaze", "name": "Kamikaze", "type": "Musuh", "hp": 1, "drawOrder": [ "body", "stripes" ], "parts": { "body": { "shape": "polygon", "color": "#444444", "x": 0, "y": 0, "rotation": 0, "points": [ 0, -25, -10, 25, 10, 25 ], "scaleX": 200, "scaleY": 130 }, "stripes": { "shape": "rect", "color": "#ffff00", "x": 0, "y": 17, "rotation": 0, "width": 14, "height": 22 } } };
    const bossTitanConfig = { "id": "boss-titan", "name": "Boss Titan", "type": "Boss", "hp": 50, "drawOrder": [ "base", "armor", "bridge", "mainCannon", "sideCannons" ], "parts": { "base": { "shape": "rect", "color": "#696969", "x": 0, "y": 0, "rotation": 0, "width": 80, "height": 80 }, "armor": { "shape": "rect", "color": "#808080", "x": 0, "y": 0, "rotation": 0, "width": 100, "height": 36 }, "bridge": { "shape": "rect", "color": "#dcdcdc", "x": 0, "y": 16, "rotation": 0, "width": 51, "height": 21 }, "mainCannon": { "shape": "circle", "color": "#ff4500", "x": 0, "y": -9, "rotation": 0, "r": 12, "animation": { "property": "opacity", "speed": 1, "amplitude": 0.5 } }, "sideCannons": { "shape": "rect", "color": "#a9a9a9", "x": 0, "y": 2, "rotation": 0, "width": 27, "height": 32 } } };
    
    const playerConfigs = { interceptor: interceptorConfig, assault: assaultConfig, bomber: bomberConfig };
    const enemyTypes = { drone: droneConfig, fighter: fighterConfig, cruiser: cruiserConfig, scout: scoutConfig, kamikaze: kamikazeConfig };
    
    const shipImageUrls = {
        interceptor: "https://raw.githubusercontent.com/fazli-bit/snakeGame/refs/heads/png/interceptor.png",
        assault: "https://raw.githubusercontent.com/fazli-bit/snakeGame/refs/heads/png/assault.png",
        bomber: "https://raw.githubusercontent.com/fazli-bit/snakeGame/refs/heads/png/bomber.png"
    };
    
    const shipStats = {
        interceptor: { hp: 1, maxHp: 2, startingBombs: 1, bombPickupAmount: 1, fireRate: 150 },
        assault: { hp: 2, maxHp: 3, startingBombs: 1, bombPickupAmount: 1, fireRate: 300 },
        bomber: { hp: 1, maxHp: 2, startingBombs: 2, bombPickupAmount: 2, fireRate: 200 }
    };
    
    // --- KELAS-KELAS PERMAINAN ---

    class GameObject {
        constructor(config, x, y, size) { this.config = config; this.x = x; this.y = y; this.size = size; this.isAlive = true; }
        draw(ctx, time) {
            const scale = this.size / 100;
            ctx.save();
            ctx.translate(this.x, this.y);
            this.config.drawOrder.forEach(partName => {
                const part = this.config.parts[partName];
                if (part) this.drawPart(ctx, part, scale, time);
            });
            ctx.restore();
        }
        drawPart(ctx, part, s, time) {
            ctx.save();
            ctx.fillStyle = part.color;
            let animX = 0, animY = 0;
            if (part.animation) {
                const animValue = Math.sin(time * part.animation.speed) * part.animation.amplitude;
                if (part.animation.property === 'y') animY = animValue;
                if (part.animation.property === 'x') animX = animValue;
                if (part.animation.property === 'opacity') ctx.globalAlpha = 0.5 + (animValue + part.animation.amplitude) / (part.animation.amplitude * 2);
            }
            ctx.translate(((part.x || 0) + animX) * s, ((part.y || 0) + animY) * s);
            ctx.rotate((part.rotation || 0) * Math.PI / 180);
            switch (part.shape) {
                case 'polygon':
                    ctx.beginPath();
                    const scaleX = (part.scaleX || 100) / 100;
                    const scaleY = (part.scaleY || 100) / 100;
                    const scaledPoints = part.points.map((p, i) => i % 2 === 0 ? p * scaleX : p * scaleY);
                    ctx.moveTo(scaledPoints[0] * s, scaledPoints[1] * s);
                    for (let i = 2; i < scaledPoints.length; i += 2) ctx.lineTo(scaledPoints[i] * s, scaledPoints[i+1] * s);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'rect': ctx.fillRect(-(part.width / 2) * s, -(part.height / 2) * s, part.width * s, part.height * s); break;
                case 'circle': ctx.beginPath(); ctx.arc(0, 0, part.r * s, 0, Math.PI * 2); ctx.fill(); break;
            }
            ctx.restore();
        }
    }
    class Player extends GameObject {
        constructor(config, stats, boardWidth, boardHeight) {
            super(config, boardWidth / 2, boardHeight - 50, 55);
            this.boardWidth = boardWidth; 
            this.boardHeight = boardHeight;
            this.speed = 5; 
            this.canShoot = true; 
            
            this.hp = stats.hp;
            this.maxHp = stats.maxHp;
            this.bombs = stats.startingBombs;
            this.bombPickupAmount = stats.bombPickupAmount;
            this.shootCooldown = stats.fireRate;
        }
        update(keys, touchDx, touchDy) {
            let dx = 0; 
            let dy = 0;
            
            if (keys['ArrowLeft'] || keys['a']) dx = -1;
            else if (keys['ArrowRight'] || keys['d']) dx = 1;

            if (keys['ArrowUp'] || keys['w']) dy = -1;
            else if (keys['ArrowDown'] || keys['s']) dy = 1;
            
            if (touchDx !== 0 || touchDy !== 0) {
                dx = touchDx;
                dy = touchDy;
            }

            this.x += dx * this.speed; this.y += dy * this.speed;
            if (this.x < this.size / 2) this.x = this.size / 2;
            if (this.x > this.boardWidth - this.size / 2) this.x = this.boardWidth - this.size / 2;
            if (this.y < this.size / 2) this.y = this.size / 2;
            if (this.y > this.boardHeight - this.size / 2) this.y = this.boardHeight - this.size / 2;
        }
        shoot() {
            if (this.canShoot) {
                this.canShoot = false;
                setTimeout(() => { this.canShoot = true; }, this.shootCooldown);
                return new Projectile(this.x, this.y - 20, 'player');
            }
            return null;
        }
        takeDamage() {
            this.hp--;
            if (this.hp <= 0) {
                this.isAlive = false;
            }
        }
        addShield() {
            if (this.hp < this.maxHp) {
                this.hp++;
            }
        }
        addBombs() {
            this.bombs += this.bombPickupAmount;
        }
        useBomb(game) {
            if (this.bombs > 0) {
                this.bombs--;
                game.triggerSpecialAttack();
                return true;
            }
            return false;
        }
        drawShield(ctx) {
            if (this.hp <= 1) return;
            const shieldCount = this.hp - 1;
            ctx.save();
            ctx.translate(this.x, this.y);
            
            for(let i = 1; i <= shieldCount; i++) {
                const alpha = 0.2 + (i * 0.2);
                ctx.fillStyle = `rgba(102, 217, 255, ${alpha})`;
                ctx.strokeStyle = `rgba(150, 230, 255, ${alpha + 0.2})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, (this.size * 0.5) + (i * 5), Math.PI * 1.15, Math.PI * 1.85);
                ctx.fill();
                ctx.stroke();
            }
            ctx.restore();
        }
    }
    class Enemy extends GameObject {
        constructor(config, x, y) {
            super(config, x, y, 50);
            this.hp = config.hp || 1;
            this.pattern = null; 
            this.initialX = x; this.initialY = y; this.age = 0;
            this.canShoot = true;
            this.shootCooldown = 2000 + Math.random() * 2000;
        }
        update(player, game) { 
            if (this.pattern) this.pattern(this, player);
            this.age++;
            if (this.y > 0 && this.canShoot && Math.random() < 0.01) {
                const p = this.shoot();
                if (p) game.projectiles.push(p);
            }
        }
        shoot() {
            this.canShoot = false;
            setTimeout(() => { this.canShoot = true; }, this.shootCooldown);
            return new Projectile(this.x, this.y + this.size / 2, 'enemy');
        }
    }
    class Boss extends Enemy {
        constructor(config, x, y) {
            super(config, x, y);
            this.size = 150;
            this.shootCooldown = 800;
            this.attackPatternCounter = 0;
        }
        update(player, game) {
             if (this.pattern) this.pattern(this, player);
            this.age++;
            if (this.y > 0 && this.canShoot && Math.random() < 0.05) {
                this.shoot(game);
            }
        }
        shoot(game) {
            this.canShoot = false;
            setTimeout(() => { this.canShoot = true; }, this.shootCooldown);
            this.attackPatternCounter++;
            if (this.attackPatternCounter % 4 === 0) {
                game.projectiles.push(new Projectile(this.x, this.y + this.size / 2, 'enemy', -2, 4));
                game.projectiles.push(new Projectile(this.x, this.y + this.size / 2, 'enemy', 0, 5));
                game.projectiles.push(new Projectile(this.x, this.y + this.size / 2, 'enemy', 2, 4));
            } else {
                game.projectiles.push(new Projectile(this.x, this.y + this.size / 2, 'enemy', 0, 6));
            }
        }
    }
    class Projectile {
        constructor(x, y, owner, dx = 0, dy = (owner === 'player' ? -8 : 5)) {
            this.x = x; this.y = y; this.owner = owner;
            this.width = 4; this.height = 10; this.isAlive = true;
            this.dx = dx; this.dy = dy;
        }
        update() { this.x += this.dx; this.y += this.dy; }
        draw(ctx) {
            ctx.fillStyle = this.owner === 'player' ? '#00ff00' : '#ff0000';
            ctx.fillRect(this.x - this.width/2, this.y, this.width, this.height);
        }
    }
    class Particle {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.size = Math.random() * 3 + 1;
            this.speedX = Math.random() * 3 - 1.5;
            this.speedY = Math.random() * 3 - 1.5;
            this.lifespan = 100;
            this.color = `hsl(${Math.random() * 60 + 20}, 100%, 50%)`;
        }
        update() { this.x += this.speedX; this.y += this.speedY; this.lifespan--; }
        draw(ctx) {
            ctx.fillStyle = this.color;
            ctx.globalAlpha = this.lifespan / 100;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }
    
    class PowerUp {
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.type = type; // 'shield' atau 'bomb'
            this.size = 25;
            this.speedY = 2;
            this.isAlive = true;
        }
        update() {
            this.y += this.speedY;
        }
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            
            ctx.fillStyle = this.type === 'shield' ? 'rgba(0, 150, 255, 0.8)' : 'rgba(255, 200, 0, 0.8)';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.font = `${this.size * 0.6}px 'Press Start 2P'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const text = this.type === 'shield' ? 'S' : 'B';
            ctx.fillText(text, 0, 2);

            ctx.restore();
        }
    }
    
    class WaveManager {
        constructor(game) {
            this.game = game;
            this.waveTimer = 3000;
            this.waveCooldown = 5000;
            this.patterns = [this.spawnLine, this.spawnV, this.spawnSides];
        }

        update(deltaTime) {
            if (this.game.isBossActive) return;
            this.waveTimer -= deltaTime;
            if (this.waveTimer <= 0) {
                const pattern = this.patterns[Math.floor(Math.random() * this.patterns.length)];
                pattern.call(this, this.game);
                this.waveTimer = Math.max(1000, this.waveCooldown - (this.game.stage * 200));
            }
        }

        spawnLine(game) {
            const enemyType = Math.random() < 0.7 ? 'drone' : 'fighter';
            const count = 5 + Math.floor(game.stage / 2);
            for (let i = 0; i < count; i++) {
                const enemy = new Enemy(enemyTypes[enemyType], (game.canvas.width / 10) + i * (game.canvas.width * 0.8 / (count-1)), -50);
                enemy.pattern = (e) => { e.y += 2 * (1 + game.stage * 0.15); };
                game.enemies.push(enemy);
            }
        }

        spawnV(game) {
            const enemyType = 'fighter';
            for (let i = -2; i <= 2; i++) {
                const enemy = new Enemy(enemyTypes[enemyType], game.canvas.width / 2 + i * 40, -50 - Math.abs(i) * 30);
                enemy.pattern = (e) => { e.y += 2.5 * (1 + game.stage * 0.15); };
                game.enemies.push(enemy);
            }
        }

        spawnSides(game) {
            const enemyType = 'scout';
            const startX = Math.random() < 0.5 ? -30 : game.canvas.width + 30;
            const speedX = (startX < 0 ? 3 : -3) * (1 + game.stage * 0.15);
            for (let i = 0; i < 3; i++) {
                const enemy = new Enemy(enemyTypes[enemyType], startX, 100 + i * 50);
                enemy.pattern = (e) => { e.x += speedX; e.y += 0.5; };
                game.enemies.push(enemy);
            }
        }
    }

    class UIManager {
        constructor() {
            this.gameContainer = document.querySelector('.game-container');
            this.mainMenu = document.getElementById('main-menu');
            this.gameArea = document.getElementById('game-area');
            this.gamepadArea = document.getElementById('gamepad-area');
            this.gameOverModal = document.getElementById('game-over-modal');
            this.score = document.getElementById('score');
            this.stage = document.getElementById('stage');
            this.bombs = document.getElementById('bombs');
            this.shipSelection = document.getElementById('ship-selection');
            this.highscoreList = document.getElementById('highscore-list');
            this.gosList1 = document.getElementById('gos-list-1');
            this.gosList2 = document.getElementById('gos-list-2');
            this.newHighscoreEntry = document.getElementById('new-highscore-entry');
            this.gameOverScores = document.getElementById('game-over-scores');
        }
        showMenu() {
            this.gameContainer.classList.remove('game-active-layout');
            document.getElementById('game-board-wrapper').classList.remove('boss-active-bg');
            this.gameArea.style.display = 'none';
            this.gamepadArea.style.display = 'none';
            this.gameOverModal.style.display = 'none';
            this.mainMenu.style.display = 'block';
        }
        showGame(isTouchDevice) {
            this.gameContainer.classList.add('game-active-layout');
            this.mainMenu.style.display = 'none'; 
            this.gameOverModal.style.display = 'none';
            this.gameArea.style.display = 'flex';
            if(isTouchDevice) {
                this.gamepadArea.style.display = 'flex';
            }
        }
        updateBombs(count) {
            this.bombs.textContent = `ðŸ’£: ${count}`;
        }
        displayHighScores(scores, { list1, list2 = null, limit = 3, showMedals = false }) {
            const medals = ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'];
            if(scores.length === 0){
                list1.innerHTML = '<li>Tiada markah</li>';
                if(list2) list2.innerHTML = '';
                return;
            }
            if (list2) {
                list1.innerHTML = scores.slice(0, 5).map((s, i) => `<li>${i + 1}. ${s.name} <span>${s.score}</span></li>`).join('');
                list2.innerHTML = scores.slice(5, 10).map((s, i) => `<li>${i + 6}. ${s.name} <span>${s.score}</span></li>`).join('');
            } else {
                list1.innerHTML = scores.slice(0, limit).map((s, i) => {
                    const medal = showMedals ? medals[i] || '' : '';
                    return `<li>${medal} ${s.name} <span>${s.score}</span></li>`;
                }).join('');
            }
        }
    }
    
    class ScoreManager {
        constructor() { this.scores = []; }
        getScores() { return this.scores; }
        async saveUserScore() { return; }
        async loadGlobalScores() { this.scores = []; return; }
        isHighScore(score) {
            if (score <= 0) return false;
            if (this.scores.length < 10) return true;
            return score > this.scores[this.scores.length - 1].score;
        }
    }

    class Game {
        constructor() {
            this.canvas = document.getElementById('game-canvas');
            this.ctx = this.canvas.getContext('2d');
            this.uiManager = new UIManager();
            this.scoreManager = new ScoreManager();
            document.getElementById('game-version').textContent = `v${GAME_VERSION}`;
            this.gameState = 'menu'; 
            this.keys = {}; 
            this.player = null; 
            this.enemies = []; 
            this.projectiles = []; 
            this.particles = [];
            this.powerUps = [];
            this.stage = 1; 
            this.score = 0; 
            this.scoreAtStageStart = 0;
            this.waveManager = new WaveManager(this);
            this.stageTimer = 45000; 
            this.isBossActive = false;
            this.lastTime = 0; 
            this.gameLoopAnimation = null;
            this.touchDx = 0; 
            this.touchDy = 0; 
            this.isTouchFiring = false; 
            this.isSpecialAttackPressed = false;
            this.screenShakeIntensity = 0;
            this.screenFlashAlpha = 0;
            
            this.bombPowerUpDroppedThisStage = false;
            this.shieldPowerUpDroppedThisStage = false;

            this.setupShipSelection(); 
            this.setupEventListeners();
            this.refreshHighScores();
        }
        
        setupShipSelection() {
            const container = this.uiManager.shipSelection;
            container.innerHTML = '';
            let isFirst = true;
            for (const configId in playerConfigs) {
                const config = playerConfigs[configId];
                const button = document.createElement('button');
                button.dataset.configId = configId;
                const img = document.createElement('img');
                img.src = shipImageUrls[configId];
                img.alt = config.name;
                const nameLabel = document.createElement('p');
                nameLabel.textContent = config.name;
                button.appendChild(img);
                button.appendChild(nameLabel);
                if (isFirst) {
                    button.classList.add('active');
                    isFirst = false;
                }
                button.addEventListener('click', () => {
                    container.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                });
                container.appendChild(button);
            }
        }
        
        setupEventListeners() {
            // PEPEJAT DIBETULKAN: Gunakan e.key tanpa toLowerCase()
            window.addEventListener('keydown', (e) => this.keys[e.key] = true);
            window.addEventListener('keyup', (e) => this.keys[e.key] = false);

            document.getElementById('start-game-button').addEventListener('click', () => this.start());
            document.getElementById('main-menu-button').addEventListener('click', () => { 
                this.gameState = 'menu';
                this.uiManager.showMenu();
            });
            document.getElementById('continue-button').addEventListener('click', () => this.continueGame());
            document.getElementById('save-score-button').addEventListener('click', async () => {
                const name = document.getElementById('player-name').value.trim().toUpperCase() || 'PLAYER';
                await this.scoreManager.saveUserScore();
                this.uiManager.newHighscoreEntry.style.display = 'none';
                this.uiManager.gameOverScores.style.display = 'block';
                await this.refreshHighScores(true); 
            });
            document.getElementById('refresh-scores-button').addEventListener('click', () => this.refreshHighScores());
            
            // PENAMBAHBAIKAN: Butang untuk tunjuk/sembunyi arahan
            document.getElementById('toggle-instructions-button').addEventListener('click', () => {
                const instructions = document.getElementById('instructions');
                const button = document.getElementById('toggle-instructions-button');
                const isHidden = instructions.style.display === 'none';
                instructions.style.display = isHidden ? 'block' : 'none';
                button.textContent = isHidden ? 'SEMBUNYI ARAHAN' : 'TUNJUK ARAHAN';
            });

            const joystickArea = document.getElementById('joystick-area');
            const joystickHandle = document.getElementById('joystick-handle');
            const fireButton = document.getElementById('fire-button');
            const specialAttackButton = document.getElementById('special-attack-button');
            let joystickTouchId = null;
            let joystickCenter = { x: 0, y: 0 };

            joystickArea.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (joystickTouchId === null) {
                    joystickTouchId = e.changedTouches[0].identifier;
                    joystickCenter = { x: joystickArea.offsetWidth / 2, y: joystickArea.offsetHeight / 2 };
                }
            }, { passive: false });
            joystickArea.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickTouchId) {
                        const touch = e.changedTouches[i];
                        const rect = joystickArea.getBoundingClientRect();
                        let x = touch.clientX - rect.left;
                        let y = touch.clientY - rect.top;
                        let dx = x - joystickCenter.x;
                        let dy = y - joystickCenter.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const maxDistance = joystickArea.offsetWidth / 2;
                        if (distance > maxDistance) {
                            dx = (dx / distance) * maxDistance;
                            dy = (dy / distance) * maxDistance;
                        }
                        joystickHandle.style.transform = `translate(${dx}px, ${dy}px)`;
                        this.touchDx = dx / maxDistance;
                        this.touchDy = dy / maxDistance;
                    }
                }
            }, { passive: false });
            const resetJoystick = () => {
                joystickTouchId = null;
                joystickHandle.style.transform = `translate(0px, 0px)`;
                this.touchDx = 0;
                this.touchDy = 0;
            };
            joystickArea.addEventListener('touchend', resetJoystick);
            joystickArea.addEventListener('touchcancel', resetJoystick);
            fireButton.addEventListener('touchstart', (e) => { e.preventDefault(); this.isTouchFiring = true; }, { passive: false });
            fireButton.addEventListener('touchend', (e) => { e.preventDefault(); this.isTouchFiring = false; }, { passive: false });
            specialAttackButton.addEventListener('touchstart', (e) => { e.preventDefault(); this.isSpecialAttackPressed = true; }, { passive: false });
            specialAttackButton.addEventListener('touchend', (e) => { e.preventDefault(); this.isSpecialAttackPressed = false; }, { passive: false });
        }

        async refreshHighScores(isGameOver = false) {
            await this.scoreManager.loadGlobalScores();
            const scores = this.scoreManager.getScores();
            if (isGameOver) {
                this.uiManager.displayHighScores(scores, { list1: this.uiManager.gosList1, list2: this.uiManager.gosList2, limit: 10 });
            } else {
                this.uiManager.displayHighScores(scores, { list1: this.uiManager.highscoreList, limit: 3, showMedals: true });
            }
        }

        start(isContinuing = false) {
            this.gameState = 'playing';
            // PEPEJAT DIBETULKAN: Logik untuk tunjuk/sembunyi gamepad
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            this.uiManager.showGame(isTouchDevice);
            
            this.canvas.width = this.canvas.offsetWidth;
            this.canvas.height = this.canvas.offsetHeight;

            if (!isContinuing) {
                this.stage = 1;
                this.score = 0;
            } else {
                this.score = 0;
            }
            const selectedConfigId = this.uiManager.shipSelection.querySelector('button.active').dataset.configId;
            const stats = shipStats[selectedConfigId];
            this.player = new Player(playerConfigs[selectedConfigId], stats, this.canvas.width, this.canvas.height);
            this.enemies = []; this.projectiles = []; this.particles = []; this.powerUps = [];
            
            this.bombPowerUpDroppedThisStage = false;
            this.shieldPowerUpDroppedThisStage = false;
            this.scoreAtStageStart = this.score;
            this.isBossActive = false;
            this.stageTimer = 45000;
            this.lastTime = performance.now();
            if (!this.gameLoopAnimation) {
                 this.gameLoop(this.lastTime);
            }
        }
        
        continueGame() { this.start(true); }

        async gameOver() {
            this.gameState = 'gameover';
            this.screenShakeIntensity = 0;
            document.getElementById('game-board-wrapper').classList.remove('boss-active-bg');
            await this.refreshHighScores(true);
            setTimeout(() => {
                if (this.gameState === 'gameover') {
                    this.uiManager.gameOverModal.style.display = 'flex';
                    if(this.scoreManager.isHighScore(this.score)) {
                        this.uiManager.newHighscoreEntry.style.display = 'block';
                        this.uiManager.gameOverScores.style.display = 'none';
                    } else {
                        this.uiManager.newHighscoreEntry.style.display = 'none';
                        this.uiManager.gameOverScores.style.display = 'block';
                    }
                }
            }, 1500);
        }
        
        gameLoop(timestamp) {
            if (this.gameState !== 'playing') {
                cancelAnimationFrame(this.gameLoopAnimation);
                this.gameLoopAnimation = null;
                return;
            };
            const deltaTime = Math.min(timestamp - this.lastTime, 100);
            this.lastTime = timestamp;
            this.update(deltaTime, timestamp);
            this.draw(timestamp);
            this.gameLoopAnimation = requestAnimationFrame((t) => this.gameLoop(t));
        }

        checkCollisions() {
            this.projectiles.forEach((p) => {
                if (!p.isAlive) return;
                if (p.owner === 'player') {
                    this.enemies.forEach((e) => {
                        if (!e.isAlive) return;
                        const dist = Math.hypot(p.x - e.x, p.y - e.y);
                        if (dist < e.size / 2 + 5) {
                            p.isAlive = false;
                            e.hp--;
                            if (e.hp <= 0) {
                                e.isAlive = false;
                                this.score += (e instanceof Boss) ? 1000 : 100;
                                this.createExplosion(e.x, e.y, 15);
                                this.tryDropPowerUp(e.x, e.y);
                                if (e instanceof Boss) { setTimeout(() => this.nextStage(), 2000); }
                            } else { this.createExplosion(p.x, p.y, 5); }
                        }
                    });
                } else { 
                    if (this.player.isAlive) {
                        const dist = Math.hypot(p.x - this.player.x, p.y - this.player.y);
                        if (dist < this.player.size / 3) { 
                            p.isAlive = false; 
                            this.player.takeDamage();
                        }
                    }
                }
            });
            this.enemies.forEach(e => {
                if (!e.isAlive || !this.player.isAlive) return;
                const dist = Math.hypot(this.player.x - e.x, this.player.y - e.y);
                if (dist < (this.player.size / 3 + e.size / 3)) {
                    this.player.takeDamage();
                    e.isAlive = false;
                    this.createExplosion(e.x, e.y, 15);
                }
            });
            this.powerUps.forEach(pu => {
                if(!pu.isAlive || !this.player.isAlive) return;
                const dist = Math.hypot(this.player.x - pu.x, this.player.y - pu.y);
                if (dist < this.player.size / 2 + pu.size / 2) {
                    if(pu.type === 'shield') {
                        this.player.addShield();
                    } else if (pu.type === 'bomb') {
                        this.player.addBombs();
                    }
                    pu.isAlive = false;
                }
            });
        }

        createExplosion(x, y, count) {
            for (let i = 0; i < count; i++) { this.particles.push(new Particle(x, y)); }
        }
        
        tryDropPowerUp(x, y) {
            const dropChance = 0.2; // 20%
            if (Math.random() > dropChance) return;
            
            const dropType = Math.random() < 0.5 ? 'shield' : 'bomb';
            if (dropType === 'shield' && !this.shieldPowerUpDroppedThisStage) {
                this.powerUps.push(new PowerUp(x, y, 'shield'));
                this.shieldPowerUpDroppedThisStage = true;
            } else if (dropType === 'bomb' && !this.bombPowerUpDroppedThisStage) {
                this.powerUps.push(new PowerUp(x, y, 'bomb'));
                this.bombPowerUpDroppedThisStage = true;
            }
        }
        
        triggerSpecialAttack() {
            this.screenFlashAlpha = 1.0;
            this.enemies.forEach(e => {
                if (e.isAlive) {
                    e.hp -= 5;
                    if (e.hp <= 0) {
                        e.isAlive = false;
                        this.score += (e instanceof Boss) ? 1000 : 100;
                        this.createExplosion(e.x, e.y, 15);
                        if (e instanceof Boss) { setTimeout(() => this.nextStage(), 2000); }
                    }
                }
            });
        }
        
        update(deltaTime, timestamp) {
            if (this.player && this.gameState === 'playing') {
                this.player.update(this.keys, this.touchDx, this.touchDy);
                if (this.keys[' '] || this.isTouchFiring) {
                    const p = this.player.shoot();
                    if (p) this.projectiles.push(p);
                }
                if(this.keys['b'] || this.isSpecialAttackPressed) {
                    if(this.player.useBomb(this)) {
                        this.keys['b'] = false;
                        this.isSpecialAttackPressed = false;
                    }
                }
            }
            this.projectiles.forEach(p => p.update());
            this.particles.forEach(p => p.update());
            this.powerUps.forEach(p => p.update());
            
            if (this.gameState === 'playing' && !this.isBossActive && deltaTime > 0) {
                this.stageTimer -= deltaTime;
                if (this.stageTimer <= 0) { this.spawnBoss(); }
            }
            if (this.gameState === 'playing') { this.waveManager.update(deltaTime || 0); }
            this.enemies.forEach(e => e.update(this.player, this));
            
            if(this.player && this.player.isAlive) this.checkCollisions();
            
            if (this.player && !this.player.isAlive && this.gameState !== 'gameover') {
                 this.createExplosion(this.player.x, this.player.y, 30);
                 this.gameOver();
            }

            this.enemies = this.enemies.filter(e => e.isAlive && e.y < this.canvas.height + e.size && e.x > -e.size && e.x < this.canvas.width + e.size);
            this.projectiles = this.projectiles.filter(p => p.isAlive && p.y > -p.height && p.y < this.canvas.height);
            this.particles = this.particles.filter(p => p.lifespan > 0);
            this.powerUps = this.powerUps.filter(p => p.isAlive && p.y < this.canvas.height + p.size);
            
            this.uiManager.score.textContent = `SKOR: ${this.score}`;
            this.uiManager.stage.textContent = `PERINGKAT: ${this.stage}`;
            if(this.player) this.uiManager.updateBombs(this.player.bombs);
            
            if (this.screenFlashAlpha > 0) {
                this.screenFlashAlpha -= 0.05;
            }
        }

        draw(timestamp) {
            this.ctx.save();
            if (this.screenShakeIntensity > 0) {
                const dx = Math.random() * this.screenShakeIntensity - this.screenShakeIntensity / 2;
                const dy = Math.random() * this.screenShakeIntensity - this.screenShakeIntensity / 2;
                this.ctx.translate(dx, dy);
            }
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
            if(this.player && this.player.isAlive) {
                this.player.drawShield(this.ctx);
                this.player.draw(this.ctx, timestamp / 100);
            }
            this.projectiles.forEach(p => p.draw(this.ctx));
            this.enemies.forEach(e => e.draw(this.ctx, timestamp / 100));
            this.particles.forEach(p => p.draw(this.ctx));
            this.powerUps.forEach(p => p.draw(this.ctx));

            if (this.screenFlashAlpha > 0) {
                this.ctx.fillStyle = `rgba(255, 255, 255, ${this.screenFlashAlpha})`;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            this.ctx.restore();
        }

        spawnBoss() {
            this.isBossActive = true;
            document.getElementById('game-board-wrapper').classList.add('boss-active-bg');
            this.screenShakeIntensity = 3;
            this.enemies = this.enemies.filter(e => !e.isAlive);
            const boss = new Boss(bossTitanConfig, this.canvas.width / 2, -100);
            boss.entryCompleteTime = null; 
            boss.pattern = (e, player) => { 
                if (e.y < 100) { e.y += 1; } 
                else {
                    if (e.entryCompleteTime === null) { e.entryCompleteTime = e.age; }
                    const timeSinceEntry = e.age - e.entryCompleteTime;
                    e.x = e.initialX + Math.sin(timeSinceEntry / 80) * (this.canvas.width / 2 - e.size / 2 - 20);
                }
            };
            this.enemies.push(boss);
        }

        nextStage() {
            if (!this.isBossActive) return;
            this.stage++;
            this.score += 1000;
            this.scoreAtStageStart = this.score;
            this.isBossActive = false;
            this.screenShakeIntensity = 0;
            document.getElementById('game-board-wrapper').classList.remove('boss-active-bg');
            this.stageTimer = 45000;
            this.waveManager.waveTimer = 3000;
            this.bombPowerUpDroppedThisStage = false;
            this.shieldPowerUpDroppedThisStage = false;
        }
    }
    
    new Game();
});
</script>

</body>
</html>

