<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ice Climber - Dev Peringkat</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { background-color: #1a1a1a; color: #f0f0f0; display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; font-family: 'Press Start 2P', cursive; }
        .main-container { display: flex; align-items: center; gap: 30px; }
        .game-column { display: flex; flex-direction: column; align-items: center; }
        .version-info-dev { font-size: 0.7rem; color: #888; margin-top: -15px; margin-bottom: 15px; }
        .game-wrapper { position: relative; }
        #game-canvas { background-color: #000; border: 4px solid #555; border-radius: 10px; display: block; }
        .side-controls { display: flex; flex-direction: column; gap: 20px; background-color: #2b2b2b; padding: 20px; border-radius: 10px; border: 2px solid #555; width: 200px; }
        #reset-level-button { background-color: #1a1a1a; color: #fff; border: 1px solid #555; padding: 10px; font-size: 0.7rem; font-family: 'Press Start 2P', cursive; cursor: pointer; }
        #reset-level-button:hover { background-color: #333; }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="game-column">
            <h1>Ice Climber (Dev Peringkat)</h1>
            <p class="version-info-dev">v-dev-level-3.0</p>
            <div class="game-wrapper">
                <canvas id="game-canvas" width="400" height="600"></canvas>
            </div>
        </div>
        <div class="side-controls">
            <button id="reset-level-button">Jana Peringkat Seterusnya</button>
        </div>
    </div>

    <script>
        const Game = {
            // --- CORE MODULE: Main game loop and state management ---
            Core: {
                init: function() {
                    Game.Controls.setupEventListeners();
                    this.resetStage();
                    this.gameLoop();
                },
                gameLoop: function() {
                    Game.Graphics.draw();
                    requestAnimationFrame(Game.Core.gameLoop);
                },
                resetStage: function(basePlatforms = null) {
                    Game.Level.generatePlatforms(basePlatforms);
                }
            },

            // --- CONSTANTS MODULE ---
            Constants: {
                PLATFORM_HEIGHT: 20,
                VERTICAL_GAP: 120,
                BLOCK_WIDTH: 40,
                LEVEL_SLOTS: 10,
                GAP_PROBABILITY: 0.4,
                NUM_NORMAL_LEVELS: 4,
            },

            // --- STATE MODULE ---
            State: {
                canvas: document.getElementById('game-canvas'),
                ctx: document.getElementById('game-canvas').getContext('2d'),
                resetLevelButton: document.getElementById('reset-level-button'),
                platforms: [],
            },
            
            // --- LEVEL MODULE ---
            Level: {
                parseLayoutToPlatforms: function(layout, y, type = 'normal') {
                    const C = Game.Constants;
                    const platforms = [];
                    for (let i = 0; i < C.LEVEL_SLOTS; i++) {
                        if (layout[i] === 'B') {
                            platforms.push({ x: i * C.BLOCK_WIDTH, y: y, width: C.BLOCK_WIDTH, height: C.PLATFORM_HEIGHT, type: type });
                        }
                    }
                    return platforms;
                },

                generatePlatformRow: function(isFirstRow) {
                    const C = Game.Constants;
                    const newLayout = Array(C.LEVEL_SLOTS).fill('B');

                    if (isFirstRow) {
                        const validGapStarts = [4, 5, 6];
                        const gapStart = validGapStarts[Math.floor(Math.random() * validGapStarts.length)];
                        newLayout[gapStart] = 'G';
                    } else {
                        // Implement new left-to-right generation with the anti-orphan rule
                        for (let j = 2; j < C.LEVEL_SLOTS - 2; j++) {
                            const previousSlot = newLayout[j - 1];

                            if (previousSlot === 'G') {
                                // If the previous slot was a gap, there's a higher chance of placing a block to create a path
                                if (Math.random() > 0.4) { // 60% chance for a Block after a Gap
                                    newLayout[j] = 'B';
                                    // --- ANTI-ORPHAN RULE ---
                                    // If we just formed 'G' then 'B', the next one MUST be 'B'.
                                    if (j + 1 < C.LEVEL_SLOTS - 2) { // Ensure we don't go out of bounds
                                        newLayout[j + 1] = 'B';
                                        j++; // We've now decided the next slot, so we skip it in the loop
                                    }
                                } else {
                                    newLayout[j] = 'G'; // It's another gap, forming '...GG...'
                                }
                            } else { // previousSlot was 'B'
                                // Standard probability for a gap if the previous was a block
                                if (Math.random() < C.GAP_PROBABILITY) {
                                    newLayout[j] = 'G';
                                } else {
                                    newLayout[j] = 'B';
                                }
                            }
                        }

                        // Final check: ensure there's at least one gap in the playable area
                        const hasMiddleGap = newLayout.slice(2, -2).includes('G');
                        if (!hasMiddleGap) {
                            const randomIndex = 2 + Math.floor(Math.random() * (C.LEVEL_SLOTS - 4));
                            newLayout[randomIndex] = 'G';
                        }
                    }
                    return newLayout;
                },

                generatePlatforms: function(basePlatformsArg = null) {
                    const S = Game.State;
                    const C = Game.Constants;
                    S.platforms = [];

                    let basePlatformLayout;
                    if(basePlatformsArg && basePlatformsArg.length > 0) {
                        basePlatformLayout = Array(C.LEVEL_SLOTS).fill('G');
                        basePlatformsArg.forEach(p => {
                            const startSlot = Math.floor(p.x / C.BLOCK_WIDTH);
                            const numSlots = Math.floor(p.width / C.BLOCK_WIDTH);
                            for(let i = 0; i < numSlots; i++) {
                                if (startSlot + i < C.LEVEL_SLOTS) {
                                    basePlatformLayout[startSlot + i] = 'B';
                                }
                            }
                        });
                    } else {
                        basePlatformLayout = Array(C.LEVEL_SLOTS).fill('B');
                    }
                    S.platforms.push(...this.parseLayoutToPlatforms(basePlatformLayout, S.canvas.height - 20, 'base'));
                    
                    let lastLevelY = S.canvas.height - 20;

                    for (let i = 1; i <= C.NUM_NORMAL_LEVELS; i++) {
                        const newLayout = this.generatePlatformRow(i === 1);
                        const currentY = lastLevelY - C.VERTICAL_GAP;
                        S.platforms.push(...this.parseLayoutToPlatforms(newLayout, currentY));
                        lastLevelY = currentY;
                    }

                    const topPlatformY = lastLevelY - C.VERTICAL_GAP;
                    const possibleStarts = [3, 4, 5];
                    const startPos = possibleStarts[Math.floor(Math.random() * possibleStarts.length)];
                    const goalLayout = Array(C.LEVEL_SLOTS).fill('G');
                    for (let j = 0; j < 3; j++) {
                        goalLayout[startPos + j] = 'B';
                    }
                    S.platforms.push(...this.parseLayoutToPlatforms(goalLayout, topPlatformY, 'top'));
                }
            },

            // --- GRAPHICS MODULE ---
            Graphics: {
                draw: function() {
                    this.drawBackground();
                    
                    Game.State.platforms.forEach(p => {
                        if (p.type === 'base') {
                            Game.State.ctx.fillStyle = '#CCCCCC';
                        } else if (p.type === 'top') {
                            Game.State.ctx.fillStyle = '#FFD700';
                        } else {
                            Game.State.ctx.fillStyle = '#FFFFFF';
                        }
                        Game.State.ctx.fillRect(p.x, p.y, p.width, p.height);
                    });
                    
                    const startPlatforms = Game.State.platforms.filter(p => p.type === 'base');
                    if (startPlatforms.length > 0) {
                        let totalX = 0;
                        let totalWidth = 0;
                        startPlatforms.forEach(p => {
                            totalX += p.x;
                            totalWidth += p.width;
                        });
                        const avgX = totalX / startPlatforms.length + (totalWidth / startPlatforms.length) / 2;
                        
                        const playerX = avgX - (Game.State.player ? Game.State.player.width / 2 : 15);
                        const playerY = startPlatforms[0].y - (Game.State.player ? Game.State.player.height : 30);
                        Game.State.ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                        if(Game.State.player) Game.State.ctx.fillRect(playerX, playerY, Game.State.player.width, Game.State.player.height);
                    }
                },
                drawBackground: function() {
                    const ctx = Game.State.ctx;
                    const canvas = Game.State.canvas;
                    const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    sky.addColorStop(0, '#0c1445');
                    sky.addColorStop(1, '#346888');
                    ctx.fillStyle = sky;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                },
            },
            
            // --- CONTROLS MODULE ---
            Controls: {
                setupEventListeners: function() {
                    Game.State.resetLevelButton.addEventListener('click', () => {
                         const topPlatforms = Game.State.platforms.filter(p => p.type === 'top');
                        Game.Core.resetStage(topPlatforms.length > 0 ? topPlatforms : null);
                    });
                }
            },
        };

        window.onload = function() { Game.Core.init(); };
    </script>
</body>
</html>

