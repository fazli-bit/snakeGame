<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ice Climber - Dev Peringkat</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { background-color: #1a1a1a; color: #f0f0f0; display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; font-family: 'Press Start+2P', cursive; }
        .main-container { display: flex; align-items: center; gap: 30px; }
        .game-column { display: flex; flex-direction: column; align-items: center; }
        .version-info-dev { font-size: 0.7rem; color: #888; margin-top: -15px; margin-bottom: 15px; }
        .game-wrapper { position: relative; }
        #game-canvas { background-color: #000; border: 4px solid #555; border-radius: 10px; display: block; }
        #hud { position: absolute; top: 15px; left: 20px; right: 20px; display: flex; justify-content: space-between; font-size: 1rem; color: #fff; text-shadow: 2px 2px #000; }
        .side-controls { display: flex; flex-direction: column; gap: 20px; background-color: #2b2b2b; padding: 20px; border-radius: 10px; border: 2px solid #555; width: 200px; }
        .control-container { display: flex; flex-direction: column; align-items: center; gap: 10px; font-size: 0.7rem; }
        .stage-presets { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; width: 100%; }
        .stage-presets button { background-color: #1a1a1a; color: #fff; border: 1px solid #555; padding: 5px; font-size: 0.6rem; font-family: 'Press Start 2P', cursive; cursor: pointer; }
        .stage-presets button:hover { background-color: #333; }
        #reset-level-button { background-color: #1a1a1a; color: #fff; border: 1px solid #555; padding: 10px; font-size: 0.7rem; font-family: 'Press Start 2P', cursive; cursor: pointer; }
        #reset-level-button:hover { background-color: #333; }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="game-column">
            <h1>Ice Climber (Dev Peringkat)</h1>
            <p class="version-info-dev">v-dev-level-1.6</p>
            <div class="game-wrapper">
                <canvas id="game-canvas" width="400" height="600"></canvas>
                <div id="hud">
                    <span>STAGE: <span id="stage">1</span></span>
                </div>
            </div>
        </div>
        <div class="side-controls">
             <div class="control-container">
                <label>Peringkat:</label>
                <div class="stage-presets">
                    <button data-stage="1">1</button>
                    <button data-stage="3">3</button>
                    <button data-stage="7">7</button>
                    <button data-stage="10">10</button>
                    <button data-stage="15">15</button>
                    <button data-stage="20">20</button>
                    <button data-stage="50">50</button>
                    <button data-stage="90">90</button>
                    <button data-stage="30">30</button>
                </div>
            </div>
            <button id="reset-level-button">Jana Peringkat Seterusnya</button>
        </div>
    </div>

    <script>
        const Game = {
            // --- CORE MODULE: Main game loop and state management ---
            Core: {
                init: function() {
                    Game.Controls.setupEventListeners();
                    this.resetStage();
                    this.gameLoop();
                },
                gameLoop: function() {
                    Game.Core.update();
                    Game.Graphics.draw();
                    requestAnimationFrame(Game.Core.gameLoop);
                },
                update: function() {
                    const S = Game.State;
                    S.globalAnimationTick++;

                    if (S.isTransitioning) {
                        S.stage++;
                        this.resetStage(S.nextStageBase);
                        S.isTransitioning = false;
                        S.nextStageBase = null;
                        return;
                    }
                    
                    Game.Player.handlePlayerInput();
                    Game.Player.updatePlayerPosition();
                    Game.Player.checkPlayerCollisions();
                    
                    const standingPlat = S.player.standingOnPlatform;
                    if (standingPlat && standingPlat.subType === 'crumbling' && S.player.dx === 0) {
                        if (standingPlat !== S.crumblingPlatformCandidate) {
                            S.crumblingPlatformCandidate = standingPlat;
                            S.crumbleCounter = 0;
                        }
                        S.crumbleCounter++;
                        if (S.crumbleCounter > 60) {
                            standingPlat.isFalling = true;
                            S.crumblingPlatformCandidate = null;
                        }
                    } else {
                        S.crumblingPlatformCandidate = null;
                        S.crumbleCounter = 0;
                    }
                    
                    for (let i = S.platforms.length - 1; i >= 0; i--) {
                        const p = S.platforms[i];
                        if (p.subType === 'moving') {
                            const nextX = p.x + p.dx;
                            let collision = false;
                            if (nextX < 0 || nextX + p.width > S.canvas.width) {
                                collision = true;
                            } else {
                                for (let j = 0; j < S.platforms.length; j++) {
                                    if (i === j) continue;
                                    const other = S.platforms[j];
                                    if (other.isFalling) continue;
                                    if (nextX < other.x + other.width && nextX + p.width > other.x && p.y === other.y) {
                                        collision = true;
                                        break;
                                    }
                                }
                            }
                            if (collision) { p.dx *= -1; }
                            p.x += p.dx;
                        }

                        if (p.isFalling) {
                            p.y += 5;
                            if (p.y > S.canvas.height) { S.platforms.splice(i, 1); }
                        }
                    }
                },
                resetStage: function(basePlatformArg = null) {
                    Game.State.stageDisplay.textContent = Game.State.stage;
                    Game.Level.generatePlatforms(basePlatformArg);
                    Game.Enemies.generateEnemies();
                    Game.Player.reset();
                }
            },

            // --- CONSTANTS MODULE ---
            Constants: {
                PLATFORM_HEIGHT: 20, VERTICAL_GAP: 120, BLOCK_WIDTH: 40, LEVEL_SLOTS: 10,
                GRAVITY: 0.5, JUMP_POWER: -12, PLAYER_SPEED: 3, ICE_FRICTION: 0.98,
            },

            // --- STATE MODULE ---
            State: {
                canvas: document.getElementById('game-canvas'),
                ctx: document.getElementById('game-canvas').getContext('2d'),
                resetLevelButton: document.getElementById('reset-level-button'),
                stagePresetButtons: document.querySelectorAll('.stage-presets button'),
                stageDisplay: document.getElementById('stage'),
                platforms: [],
                enemies: [],
                globalAnimationTick: 0,
                stage: 1,
                isTransitioning: false,
                nextStageBase: null,
                 player: { 
                    width: 30, height: 30, x: 0, y: 0, dx: 0, dy: 0,
                    onGround: false, standingOnPlatform: null
                },
                crumblingPlatformCandidate: null,
                crumbleCounter: 0,
            },
            
            // --- LEVEL MODULE ---
            Level: {
                stageProgression: [
                    { range: [1, 5],   lowerRows: { blocks: ['B'] },           upperRows: { blocks: ['B'] },           enemies: [] },
                    { range: [6, 10],  lowerRows: { blocks: ['B'] },           upperRows: { blocks: ['B', 'I'] },      enemies: ['GROUND_MONSTER'] },
                    { range: [11, 15], lowerRows: { blocks: ['B', 'I'] },      upperRows: { blocks: ['I'] },           enemies: ['GROUND_MONSTER'] },
                    { range: [16, 20], lowerRows: { blocks: ['B', 'I'] },      upperRows: { blocks: ['I', 'M'] },      enemies: ['GROUND_MONSTER'] },
                    { range: [21, 25], lowerRows: { blocks: ['B', 'I', 'M'] }, upperRows: { blocks: ['I', 'M', 'C'] }, enemies: ['GROUND_MONSTER'] },
                    { range: [26, 30], lowerRows: { blocks: ['B', 'I', 'M', 'C'] }, upperRows: { blocks: ['B', 'I', 'M', 'C'] }, enemies: ['GROUND_MONSTER']},
                    { range: [31, 999],lowerRows: { blocks: ['B', 'I', 'M', 'C'] }, upperRows: { blocks: ['B', 'I', 'M', 'C'] }, enemies: ['GROUND_MONSTER']}
                ],

                getCurrentProgression: function() {
                    const stage = Game.State.stage;
                    return this.stageProgression.find(p => stage >= p.range[0] && stage <= p.range[1]) || this.stageProgression[this.stageProgression.length - 1];
                },

                parseLayoutToPlatforms: function(layout, y, type = 'normal') {
                    const C = Game.Constants;
                    let platforms = [];
                    for (let i = 0; i < C.LEVEL_SLOTS; i++) {
                        const char = layout[i];
                        const x = i * C.BLOCK_WIDTH;
                        let commonProps = { y: y, height: C.PLATFORM_HEIGHT, type: type };
                        if (char === 'B' || char === 'I' || char === 'M') {
                            let p = { ...commonProps, x: x, width: C.BLOCK_WIDTH, subType: 'normal' };
                            if (char === 'I') p.subType = 'icy';
                            if (char === 'M') {
                                p.subType = 'moving'; p.dx = (Math.random() < 0.5 ? 1 : -1) * 0.8;
                            }
                            platforms.push(p);
                        } else if (char === 'C') {
                            let crumblingProps = { ...commonProps, width: C.BLOCK_WIDTH / 2, subType: 'crumbling', isFalling: false };
                            platforms.push({ ...crumblingProps, x: x, id: Math.random() });
                            platforms.push({ ...crumblingProps, x: x + C.BLOCK_WIDTH / 2, id: Math.random() });
                        }
                    }
                    return platforms;
                },

                generatePlatformRow: function(isFirstRow, isTopRow) {
                    const S = Game.State;
                    const C = Game.Constants;
                    let layout = Array(C.LEVEL_SLOTS).fill('B');

                    if (isFirstRow) {
                        const gapStart = 3 + Math.floor(Math.random() * 3);
                        layout[gapStart] = 'G'; layout[gapStart + 1] = 'G';
                        return layout;
                    }
                    
                    const progression = this.getCurrentProgression();
                    const allowedTypes = isTopRow ? progression.upperRows.blocks : progression.lowerRows.blocks;

                    // Pass 1: Place a mandatory double gap
                    let gapPlaced = false;
                    for (let i = 1; i < C.LEVEL_SLOTS - 2 && !gapPlaced; i++) {
                        if (Math.random() < 0.3) {
                            layout[i] = 'G'; layout[i + 1] = 'G';
                            gapPlaced = true;
                        }
                    }
                    if (!gapPlaced) {
                        const gapStart = 2 + Math.floor(Math.random() * (C.LEVEL_SLOTS - 5));
                        layout[gapStart] = 'G'; layout[gapStart + 1] = 'G';
                    }

                    // Pass 2: Apply stage-based progression on solid blocks
                    for (let i = 0; i < C.LEVEL_SLOTS; i++) {
                        if (layout[i] === 'B') {
                            const typeRoll = allowedTypes[Math.floor(Math.random() * allowedTypes.length)];
                            if (typeRoll === 'M' && i > 0 && i < C.LEVEL_SLOTS - 1 && layout[i-1] === 'B' && layout[i+1] === 'B') {
                                layout[i-1] = 'G'; layout[i] = 'M'; layout[i+1] = 'G';
                                i++; 
                            } else if (typeRoll === 'C' && i < C.LEVEL_SLOTS - 1 && layout[i+1] === 'B') {
                                layout[i] = 'C'; layout[i+1] = 'C';
                                i++;
                            } else if (typeRoll === 'I') {
                                layout[i] = 'I';
                            }
                        }
                    }

                    // Pass 3: Final cleanup and anti-orphan
                    if (['C', 'M', 'G'].includes(layout[0])) layout[0] = 'B';
                    if (['C', 'M', 'G'].includes(layout[C.LEVEL_SLOTS - 1])) layout[C.LEVEL_SLOTS - 1] = 'B';
                    for (let j = 1; j < C.LEVEL_SLOTS -1; j++) {
                         if (['G', 'C'].includes(layout[j-1]) && layout[j] === 'B') {
                            layout[j+1] = 'B';
                         }
                    }
                    
                    return layout;
                },

                generatePlatforms: function(basePlatformArg = null) {
                    const S = Game.State;
                    const C = Game.Constants;
                    S.platforms = [];
                    
                    let basePlatform;
                    if (basePlatformArg) {
                        basePlatform = { x: basePlatformArg.x, y: S.canvas.height - 20, width: basePlatformArg.width, height: C.PLATFORM_HEIGHT, type: 'base', subType: 'normal' };
                    } else {
                        basePlatform = { x: 0, y: S.canvas.height - 20, width: S.canvas.width, height: C.PLATFORM_HEIGHT, type: 'base', subType: 'normal' };
                        basePlatform.x -= S.player.width * 2; basePlatform.width += S.player.width * 4;
                    }
                    S.platforms.push(basePlatform);
                                        
                    let rowCount = 0;
                    let tempY = basePlatform.y;
                    while(tempY > C.VERTICAL_GAP + 80) { rowCount++; tempY -= C.VERTICAL_GAP; }

                    let currentY = basePlatform.y;
                    for(let i=0; i < rowCount; i++) {
                        currentY -= C.VERTICAL_GAP;
                        const isFirst = (i === 0);
                        const isTopRow = (i >= rowCount - 2);
                        
                        const newLayout = this.generatePlatformRow(isFirst, isTopRow);
                        const newPlatforms = this.parseLayoutToPlatforms(newLayout, currentY);

                        if(newPlatforms.length > 0) {
                           newPlatforms[0].x -= S.player.width * 2; newPlatforms[0].width += S.player.width * 2;
                           newPlatforms[newPlatforms.length - 1].width += S.player.width * 2;
                        }
                        S.platforms.push(...newPlatforms);
                    }

                    const topPlatformY = 0 - C.PLATFORM_HEIGHT / 2;
                    S.platforms.push({x: 150, y: topPlatformY, width: 100, height: C.PLATFORM_HEIGHT, type: 'top', subType: 'normal' });
                }
            },
            
            // --- ENEMIES MODULE ---
            Enemies: {
                generateEnemies: function() {
                    const S = Game.State;
                    S.enemies = [];
                    const progression = Game.Level.getCurrentProgression();
                    const allowedEnemies = progression.enemies;
                    if (allowedEnemies.length === 0) return;

                    let numEnemies = 0;
                    if (S.stage >= 20) numEnemies = 3;
                    else if (S.stage >= 10) numEnemies = 2;
                    else if (S.stage >= 3) numEnemies = 1;

                    const allMiddlePlatforms = S.platforms.filter(p => p.type !== 'base' && p.type !== 'top');
                    if (allMiddlePlatforms.length === 0) return;
                    
                    const highestY = Math.min(...allMiddlePlatforms.map(p => p.y));

                    const spawnablePlatforms = allMiddlePlatforms.filter(p => 
                        p.y > highestY &&
                        p.subType !== 'moving' && 
                        p.subType !== 'crumbling'
                    );

                    if (spawnablePlatforms.length === 0) return;

                    for (let i = 0; i < numEnemies; i++) {
                        const platform = spawnablePlatforms[Math.floor(Math.random() * spawnablePlatforms.length)];
                        const enemyWidth = 25;
                        const enemyHeight = 25;

                        const visibleStartX = Math.max(0, platform.x);
                        const visibleEndX = Math.min(S.canvas.width, platform.x + platform.width);
                        const visibleWidth = visibleEndX - visibleStartX;

                        if (visibleWidth < enemyWidth) continue; // Skip if platform is too small on-screen

                        const spawnX = visibleStartX + (visibleWidth / 2) - (enemyWidth / 2);
                        
                        const enemyType = allowedEnemies[Math.floor(Math.random() * allowedEnemies.length)]; 
                        const enemy = {
                            type: enemyType,
                            width: enemyWidth, height: enemyHeight,
                            x: spawnX,
                            y: platform.y - enemyHeight
                        };
                        S.enemies.push(enemy);
                    }
                }
            },

            // --- PLAYER MODULE ---
            Player: {
                reset: function() {
                    const S = Game.State; const p = S.player;
                    const startPlatform = S.platforms[0];
                    p.x = (S.canvas.width / 2) - (p.width / 2); p.y = startPlatform.y - p.height;
                    p.dx = 0; p.dy = 0; p.onGround = true; p.standingOnPlatform = startPlatform;
                },
                handlePlayerInput: function() {
                    const p = Game.State.player, C = Game.Constants, keys = Game.Controls.keys;
                    const onIce = p.onGround && p.standingOnPlatform && p.standingOnPlatform.subType === 'icy';
                    if (keys.left) {
                        if (onIce) { if (p.dx > 0) p.dx -= 0.4; p.dx = Math.max(p.dx - 0.2, -C.PLAYER_SPEED); } 
                        else { p.dx = -C.PLAYER_SPEED; }
                    } else if (keys.right) {
                        if (onIce) { if (p.dx < 0) p.dx += 0.4; p.dx = Math.min(p.dx + 0.2, C.PLAYER_SPEED); }
                         else { p.dx = C.PLAYER_SPEED; }
                    } else if (p.onGround) {
                        if (onIce) { p.dx *= C.ICE_FRICTION; } else { p.dx = 0; }
                    }
                    if (Math.abs(p.dx) < 0.1) p.dx = 0;
                    if (keys.up && p.onGround) { p.dy = C.JUMP_POWER; p.onGround = false; }
                },
                updatePlayerPosition: function() {
                    const p = Game.State.player;
                    p.dy += Game.Constants.GRAVITY; p.x += p.dx; p.y += p.dy;
                    if (p.x + p.width < 0) p.x = Game.State.canvas.width;
                    else if (p.x > Game.State.canvas.width) p.x = -p.width;
                    if (p.y > Game.State.canvas.height) this.reset();
                },
                checkPlayerCollisions: function() {
                    const p = Game.State.player;
                    p.onGround = false; p.standingOnPlatform = null;

                    for (let i = Game.State.platforms.length - 1; i >= 0; i--) {
                        const plat = Game.State.platforms[i];
                        if (plat && plat.isFalling) continue;
                        if (!plat) continue;

                        if (p.x + p.width > plat.x && p.x < plat.x + plat.width) {
                            if (p.dy >= 0 && (p.y + p.height) >= plat.y && (p.y + p.height - p.dy) <= plat.y) {
                                p.dy = 0; p.onGround = true; p.y = plat.y - p.height;
                                p.standingOnPlatform = plat;
                                if (plat.subType === 'moving') p.x += plat.dx;
                                if (plat.type === 'top') {
                                    Game.State.isTransitioning = true;
                                    Game.State.nextStageBase = plat;
                                }
                            }
                            if (p.dy < 0 && p.y <= (plat.y + plat.height) && (p.y - p.dy) > (plat.y + plat.height)) {
                                p.dy = 0;
                                if (plat.subType === 'crumbling') { plat.isFalling = true; }
                            }
                        }
                    }
                }
            },

            // --- GRAPHICS MODULE ---
            Graphics: {
                draw: function() {
                    this.drawBackground();
                    Game.State.platforms.forEach(p => {
                        const ctx = Game.State.ctx;
                        let shakeX = (p === Game.State.crumblingPlatformCandidate && !p.isFalling) ? Math.sin(Game.State.globalAnimationTick * 0.8) * 1.5 : 0;
                        switch(p.subType) {
                            case 'icy': ctx.fillStyle = '#A8D8F0'; break;
                            case 'moving': ctx.fillStyle = '#B2B2B2'; break;
                            case 'crumbling':
                                ctx.fillStyle = '#E0E0E0'; ctx.fillRect(p.x + shakeX, p.y, p.width, p.height);
                                ctx.strokeStyle = '#A0A0A0'; ctx.lineWidth = 1; ctx.beginPath();
                                ctx.moveTo(p.x + p.width/2 + shakeX, p.y + 2); ctx.lineTo(p.x + p.width/2 + shakeX, p.y + p.height - 2);
                                ctx.stroke(); return;
                            default:
                                if (p.type === 'base') ctx.fillStyle = '#CCCCCC';
                                else if (p.type === 'top') ctx.fillStyle = '#FFD700';
                                else ctx.fillStyle = '#FFFFFF';
                        }
                        ctx.fillRect(p.x, p.y, p.width, p.height);
                    });
                    this.drawEnemies();
                    this.drawPlayer();
                },
                drawBackground: function() {
                    const ctx = Game.State.ctx, canvas = Game.State.canvas;
                    const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    sky.addColorStop(0, '#0c1445'); sky.addColorStop(1, '#346888');
                    ctx.fillStyle = sky; ctx.fillRect(0, 0, canvas.width, canvas.height);
                },
                drawPlayer: function() {
                    const S = Game.State, p = S.player, x = p.x, y = p.y;
                    S.ctx.fillStyle = '#8B4513'; S.ctx.fillRect(x + 2, y, p.width - 4, p.height - 2);
                    S.ctx.fillStyle = '#4682B4'; S.ctx.fillRect(x, y + p.height - 8, p.width, 5);
                    S.ctx.fillStyle = '#FFDAB9'; S.ctx.fillRect(x + 7, y + 5, p.width - 14, 12);
                    S.ctx.fillStyle = '#000000'; S.ctx.fillRect(x + 10, y + 10, 3, 3); S.ctx.fillRect(x + 17, y + 10, 3, 3);
                },
                drawEnemies: function() {
                    const S = Game.State;
                    S.ctx.fillStyle = '#FF4136'; // Red for enemies
                    S.enemies.forEach(e => {
                        S.ctx.fillRect(e.x, e.y, e.width, e.height);
                    });
                }
            },
            
            // --- CONTROLS MODULE ---
            Controls: {
                keys: { left: false, right: false, up: false },
                setupEventListeners: function() {
                    Game.State.resetLevelButton.addEventListener('click', () => {
                        Game.State.stage++;
                        Game.Core.resetStage();
                    });
                    Game.State.stagePresetButtons.forEach(b => {
                        b.addEventListener('click', (e) => {
                            Game.State.stage = parseInt(e.target.dataset.stage, 10);
                            Game.Core.resetStage();
                        });
                    });
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'ArrowLeft') this.keys.left = true;
                        if (e.key === 'ArrowRight') this.keys.right = true;
                        if (e.key === 'ArrowUp') this.keys.up = true;
                    });
                    document.addEventListener('keyup', (e) => {
                        if (e.key === 'ArrowLeft') this.keys.left = false;
                        if (e.key === 'ArrowRight') this.keys.right = false;
                        if (e.key === 'ArrowUp') this.keys.up = false;
                    });
                }
            },
        };

        window.onload = function() { Game.Core.init(); };
    </script>
</body>
</html>

