<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ice Climber v1.0.0.1</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* CSS Lengkap dari v0.9.1.0 */
        html, body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
        }
        body { display: flex; align-items: center; justify-content: center; }
        .main-container { display: flex; align-items: center; gap: 30px; }
        .game-column { display: flex; flex-direction: column; align-items: center; }
        .game-title-bar { margin-bottom: 15px; text-align: center; }
        .game-wrapper { position: relative; }
        #game-canvas { background-color: #000; border: 4px solid #555; border-radius: 10px; display: block; }
        .menu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; border-radius: 6px; text-align: center; color: #fff; text-shadow: 3px 3px #000; }
        .menu h2, .menu h3 { font-size: 2rem; margin-bottom: 20px; }
        .menu h3 { font-size: 1.5rem; margin-bottom: 25px; }
        .menu button { background-color: #00ff00; color: #000; border: none; padding: 15px 30px; font-family: 'Press Start 2P', cursive; font-size: 1.2rem; border-radius: 5px; cursor: pointer; transition: background-color 0.2s, transform 0.2s; margin-top: 20px; text-shadow: none; }
        .menu button:hover { background-color: #ffff00; transform: scale(1.05); }
        .menu button:disabled { background-color: #555; color: #999; cursor: not-allowed; transform: none; }
        .game-over-buttons { display: flex; gap: 20px; }
        .game-over-buttons button { font-size: 1rem; padding: 12px 24px; }
        #character-selection { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center; max-width: 300px;}
        .char-select { border: 4px solid #555; border-radius: 8px; padding: 10px; cursor: pointer; transition: border-color 0.2s, transform 0.2s; }
        .char-select:hover { border-color: #ffff00; transform: scale(1.05); }
        .char-select.selected { border-color: #00ff00; }
        .char-select canvas { width: 60px; height: 60px; background-color: #333; border-radius: 4px; }
        #hud { position: absolute; top: 15px; left: 20px; right: 20px; display: flex; justify-content: space-between; align-items: center; font-size: 1rem; color: #fff; text-shadow: 2px 2px #000; pointer-events: none; }
        .version-info { font-size: 0.7rem; color: #888; margin-top: -15px; margin-bottom: 15px; }
        .side-controls { flex-direction: column; gap: 20px; background-color: #2b2b2b; padding: 20px; border-radius: 10px; border: 2px solid #555; width: 200px; }
        .control-container { display: flex; flex-direction: column; align-items: center; gap: 10px; font-size: 0.7rem; }
        .control-container input[type="range"] { width: 100%; }
        .stage-presets { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; width: 100%; }
        .stage-presets button { background-color: #1a1a1a; color: #fff; border: 1px solid #555; padding: 5px; font-size: 0.6rem; font-family: 'Press Start 2P', cursive; cursor: pointer; }
        .stage-presets button:hover { background-color: #333; }
        .stage-presets button.selected { background-color: #00ff00; color: #000; }
        #debug-panel { font-size: 0.6rem; line-height: 1.5; }
        #debug-panel h3 { font-size: 0.8rem; color: #ffff00; margin: 0 0 10px 0; text-align: center; width: 100%; border-bottom: 1px solid #555; padding-bottom: 10px; }
        #debug-panel p { margin: 2px 0; display: flex; justify-content: space-between; width: 100%; }
        #debug-panel span { color: #00ff00; min-width: 60px; text-align: right; }
        #on-screen-controls { display: none; width: 100%; background-color: #111; padding: 10px; box-sizing: border-box; }
        .d-pad { position: relative; width: 150px; height: 150px; }
        .d-pad-btn { position: absolute; width: 50px; height: 50px; background-color: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.4); display: flex; align-items: center; justify-content: center; color: rgba(255, 255, 255, 0.7); font-size: 2rem; -webkit-user-select: none; user-select: none; transition: background-color 0.1s; }
        .d-pad .up { top: 0; left: 50px; } .d-pad .left { top: 50px; left: 0; } .d-pad .right { top: 50px; left: 100px; } .d-pad .down { top: 100px; left: 50px; }
        .action-buttons { display: flex; gap: 20px; }
        .action-btn { width: 70px; height: 70px; background-color: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.4); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; color: rgba(255, 255, 255, 0.7); -webkit-user-select: none; user-select: none; transition: background-color 0.1s; }
        .d-pad-btn.pressed, .action-btn.pressed { background-color: rgba(255, 255, 255, 0.5); }
        #debug-panel, .side-controls { display: none; }
        .main-container.show-debug #debug-panel, .main-container.show-debug .side-controls { display: flex; }
        body.is-mobile .main-container { flex-direction: column; width: 100%; height: 100%; padding: 0; gap: 0; }
        body.is-mobile .game-column { flex-grow: 1; width: 100%; height: 100%; display: flex; flex-direction: column; }
        body.is-mobile .game-title-bar { display: none; }
        body.is-mobile .game-wrapper { width: 100%; flex-grow: 1; display: flex; position: relative; min-height: 0; }
        body.is-mobile #game-canvas { width: 100%; height: 100%; object-fit: contain; border: none; border-radius: 0; }
        body.is-mobile #on-screen-controls { display: flex; justify-content: space-around; align-items: center; height: 180px; flex-shrink: 0; }
        body.is-mobile #debug-panel, body.is-mobile .side-controls { display: none !important; }
        #highscore-list, #start-highscore-display { margin-top: 10px; font-size: 0.7rem; line-height: 1.6; color: #ffff00; max-height: 150px; overflow-y: auto; text-align: left; padding: 0 15px;}
        #highscore-list h4, #start-menu-highscore h4 { font-size: 1rem; color: #fff; margin-bottom: 10px; text-align: center;}
        #highscore-list p, #start-highscore-display p { margin: 4px 0; white-space: pre; }
        #start-menu-highscore { width: 80%; margin-bottom: 20px; }
        #refresh-highscore-btn { cursor: pointer; display: inline-block; transition: transform 0.2s; }
        #refresh-highscore-btn:hover { transform: scale(1.2) rotate(90deg); }
        .menu-option { font-size: 1rem; color: #fff; cursor: pointer; margin-top: 15px; padding: 8px; transition: transform 0.2s, color 0.2s; }
        .menu-option:hover { color: #ffff00; transform: scale(1.05); }
        .instructions-text { font-size: 0.8rem; line-height: 1.8; max-width: 80%; text-align: left; margin-bottom: 30px; }
        .instructions-text span { color: #ffff00; display: inline-block; width: 100px; }
        #hud > div:first-child { display: flex; align-items: center; gap: 15px; flex-basis: 60%; }
        #hud > span:last-child { text-align: right; flex-basis: 40%;}
        #hp-hearts { color: red; letter-spacing: 2px; }
        #debug-code-menu, #name-input-menu { z-index: 10; padding: 20px; background-color: #2b2b2b; border: 2px solid #555; border-radius: 10px;}
        #debug-code-menu input, #name-input-menu input { background-color: #1a1a1a; border: 1px solid #555; color: #fff; padding: 10px; text-align: center; font-family: 'Press Start 2P', cursive; }
        #debug-code-menu button, #name-input-menu button { font-size: 0.8rem; margin-top: 15px; text-shadow: none;}
    </style>
</head>
<body>
    <div class="main-container">
        <div id="debug-panel" class="side-controls">
            <h3>Maklumat Asas</h3>
            <p>Posisi X: <span id="debug-player-x">0</span></p>
            <p>Posisi Y: <span id="debug-player-y">0</span></p>
            <p>Halaju X: <span id="debug-player-dx">0</span></p>
            <p>Halaju Y: <span id="debug-player-dy">0</span></p>
            <p>Di Atas Tanah: <span id="debug-player-onground">false</span></p>
            <p>Pelanggaran: <span id="debug-collision">Tidak</span></p>
        </div>
        <div class="game-column">
            <div class="game-title-bar">
                 <h1>Ice Climber</h1>
                 <p class="version-info">v1.0.0.1 (Engine Rework & Bugfix)</p>
            </div>
            <div class="game-wrapper">
                <canvas id="game-canvas" width="400" height="600"></canvas>
                <div id="hud" style="display: none;">
                    <div>
                        <span>SCORE: <span id="score">0</span></span>
                        <div id="hp-hearts"></div>
                    </div>
                    <span>STAGE: <span id="stage">1</span></span>
                </div>
                <div id="start-menu" class="menu">
                    <div id="start-menu-highscore">
                         <h4>HIGH SCORE <span id="refresh-highscore-btn">🔄</span></h4>
                         <div id="start-highscore-display"><p>Loading...</p></div>
                    </div>
                    <h3>Pilih Watak:</h3>
                    <div id="character-selection">
                        <div class="char-select selected" data-char="ESKIMO">
                            <canvas id="eskimo-preview" width="60" height="60"></canvas>
                        </div>
                        <div class="char-select" data-char="PENGUIN">
                            <canvas id="penguin-preview" width="60" height="60"></canvas>
                        </div>
                        <div class="char-select" data-char="ESKIMO_FEMALE">
                            <canvas id="eskimo_female-preview" width="60" height="60"></canvas>
                        </div>
                         <div class="char-select" data-char="TERMINATOR">
                            <canvas id="terminator-preview" width="60" height="60"></canvas>
                        </div>
                    </div>
                    <button id="start-button">Start Game</button>
                    <div id="instructions-button" class="menu-option">ARAHAN</div>
                </div>
                <div id="game-over-menu" class="menu" style="display: none;">
                    <h2 style="color: #ff4136;">GAME OVER</h2>
                    <p style="font-size: 1rem;">SCORE: <span id="final-score">0</span></p>
                    <p style="font-size: 0.8rem;">REACHED STAGE: <span id="final-stage">1</span></p>
                    <div id="highscore-list"><h4>Loading Scores...</h4></div>
                    <div class="game-over-buttons">
                        <button id="continue-button">Sambung</button>
                        <button id="restart-button">Mula Semula</button>
                    </div>
                </div>
                <div id="instructions-menu" class="menu" style="display: none;">
                    <h2>ARAHAN</h2>
                    <div class="instructions-text">
                        <p><span>Anak Panah &#8592; &#8594;</span> : Bergerak</p>
                        <p><span>D / &#8593;</span> : Lompat</p>
                        <p><span>Anak Panah &#8595;</span> : Tunduk</p>
                        <p><span>S</span> : Guna Item</p>
                        <hr style="border-color: #555; margin: 15px 0;">
                        <p><span>Butang D-Pad</span> : Bergerak/Tunduk</p>
                        <p><span>Butang A</span> : Lompat</p>
                        <p><span>Butang B</span> : Guna Item</p>
                    </div>
                    <button id="back-to-start-menu-button">KEMBALI</button>
                </div>
                <div id="debug-code-menu" class="menu" style="display: none;">
                    <h3>Enter Debug Code</h3>
                    <input type="password" id="debug-code-input" maxlength="4">
                    <button id="debug-code-submit">Enter</button>
                </div>
                <div id="name-input-menu" class="menu" style="display: none;">
                    <h3>New High Score!</h3>
                    <p>Enter your name (3-8 chars):</p>
                    <input type="text" id="name-input-field" maxlength="8">
                    <button id="name-input-submit">Submit</button>
                </div>
            </div>
            <div id="on-screen-controls">
                <div class="d-pad">
                    <div id="btn-up" class="d-pad-btn up">&#9652;</div>
                    <div id="btn-left" class="d-pad-btn left">&#9664;</div>
                    <div id="btn-right" class="d-pad-btn right">&#9654;</div>
                    <div id="btn-down" class="d-pad-btn down">&#9662;</div>
                </div>
                <div class="action-buttons">
                    <div id="btn-b" class="action-btn">B</div>
                    <div id="btn-a" class="action-btn">A</div>
                </div>
            </div>
        </div>
        <div class="side-controls">
            <div class="control-container">
                <label>Peringkat:</label>
                <div class="stage-presets">
                    <button data-stage="1">1</button>
                    <button data-stage="3">3</button>
                    <button data-stage="7">7</button>
                    <button data-stage="10">10</button>
                    <button data-stage="15">15</button>
                    <button data-stage="20">20</button>
                    <button data-stage="31">31</button>
                    <button data-stage="50">50</button>
                    <button data-stage="90">90</button>
                    <button data-stage="101">101</button>
                    <button data-stage="102">102</button>
                </div>
            </div>
            <div class="control-container">
                <label for="decoration-slider">Kekerapan Hiasan:</label>
                <input type="range" id="decoration-slider" min="0" max="50" value="50">
                <span id="decoration-value">50%</span>
            </div>
             <div class="control-container">
                <label>Musuh Ujian (102):</label>
                <div id="enemy-selection" class="stage-presets" style="grid-template-columns: 1fr 1fr;">
                    <button data-enemy="GROUND_MONSTER" class="selected">Monster</button>
                    <button data-enemy="AWAN_HANTU">Hantu</button>
                    <button data-enemy="ICICLE">Icicle</button>
                    <button data-enemy="BAT">Kelawar</button>
                </div>
            </div>
            <button id="reset-platforms-button">Reset Platforms</button>
        </div>
    </div>

    <script type="module">
	// Import Firebase modules
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, getDoc, setDoc, collection, query, orderBy, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

// Mobile detection
const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
if (isMobile) {
    document.body.classList.add('is-mobile');
}

const Game = {
    Core: {},
    Constants: {},
    State: {},
    Assets: {},
    Player: {},
    Enemies: {},
    Level: {},
    Graphics: {},
    Controls: {},
    Debug: {},
    Firebase: {}
};

Object.assign(Game.Core, {
    animationFrameId: null,
    init: function() {
        Game.Firebase.init();
        Game.State.decorationValue.textContent = `${Game.State.decorationSlider.value}%`;
        Game.Core.resetGame();
        Game.Graphics.draw();
        Game.Graphics.drawCharacterPreviews();
        Game.Controls.setupEventListeners();
    },
    gameLoop: function() {
        Game.Core.update();
        Game.Graphics.draw();
        Game.Core.animationFrameId = requestAnimationFrame(Game.Core.gameLoop);
    },
    update: function() {
        if (Game.State.gameOver) return;
        Game.State.globalAnimationTick++;
        if (Game.State.isTransitioning) {
            Game.Core.handleStageTransition();
            return;
        }
        if (Game.State.player.hitTimer > 0) {
            Game.State.player.hitTimer--;
        } else {
            Game.State.player.isHit = false;
        }
        if (Game.State.player.powerUpCooldown > 0) {
            Game.State.player.powerUpCooldown--;
        }
        if (Game.State.player.platformToDropThrough && Game.State.player.y > Game.State.player.platformToDropThrough.y + Game.Constants.PLATFORM_HEIGHT) {
            Game.State.player.platformToDropThrough = null;
        }
        Game.Enemies.updateEnemies();
        Game.Enemies.updateProjectiles();
        Game.Player.handlePlayerInput();
        Game.Player.updateActions();
        Game.Player.updatePlayerPosition();
        Game.Player.checkPlayerCollisions();
        Game.Debug.updateDebugInfo();
        Game.Graphics.updateHpDisplay();
        const S = Game.State;
        const standingPlat = S.player.standingOnPlatform;
        if (standingPlat && standingPlat.subType === 'crumbling' && S.player.dx === 0) {
            if (standingPlat !== S.crumblingPlatformCandidate) {
                S.crumblingPlatformCandidate = standingPlat;
                S.crumbleCounter = 0;
            }
            S.crumbleCounter++;
            if (S.crumbleCounter > 60) {
                standingPlat.isFalling = true;
                S.crumblingPlatformCandidate = null;
            }
        } else {
            S.crumblingPlatformCandidate = null;
            S.crumbleCounter = 0;
        }
        for (let i = S.platforms.length - 1; i >= 0; i--) {
            const p = S.platforms[i];
            if (p.subType === 'moving') {
                const nextX = p.x + p.dx;
                let collision = false;
                if (nextX < 0 || nextX + p.width > S.canvas.width) {
                    collision = true;
                } else {
                    for (let j = 0; j < S.platforms.length; j++) {
                        if (i === j) continue;
                        const other = S.platforms[j];
                        if (other.isFalling) continue;
                        if (nextX < other.x + other.width && nextX + p.width > other.x && p.y < other.y + other.height && p.y + p.height > other.y) {
                            collision = true;
                            break;
                        }
                    }
                }
                if (collision) { p.dx *= -1; }
                p.x += p.dx;
            }
            if (p.isFalling) {
                p.y += 5;
                if (p.y > S.canvas.height) { S.platforms.splice(i, 1); }
            }
        }
        if (S.player.onGround && S.player.standingOnPlatform && S.player.standingOnPlatform.type === 'top' && ![101, 102].includes(S.stage)) {
            S.isTransitioning = true;
        }
        if (S.player.y > S.canvas.height) {
            if (![101, 102].includes(S.stage)) {
                S.player.hp = 0;
                S.gameOver = true;
            } else {
                const floor = S.platforms[0];
                S.player.y = floor.y - S.player.height;
                S.player.x = 20;
                S.player.dy = 0;
                S.player.dx = 0;
            }
        }
        if (S.gameOver) {
            cancelAnimationFrame(Game.Core.animationFrameId);
            S.finalScoreDisplay.textContent = S.score;
            S.finalStageDisplay.textContent = S.stage;
            S.continueButton.disabled = S.checkpointStage <= 1;
            S.gameOverMenu.style.display = 'flex';
            S.hud.style.display = 'none';
            if (isMobile) {
                document.getElementById('on-screen-controls').style.display = 'none';
            }
            if (!S.debugModeActive) {
                Game.Firebase.handleNewHighScore();
            } else {
                Game.Firebase.loadHighScores();
            }
        }
    },
    startGame: function() {
        const S = Game.State;
        S.startMenu.style.display = 'none';
        S.gameOverMenu.style.display = 'none';
        S.hud.style.display = 'flex';
        if (isMobile) {
            document.getElementById('on-screen-controls').style.display = 'flex';
        }
        if (Game.Core.animationFrameId) cancelAnimationFrame(Game.Core.animationFrameId);
        S.stage = S.checkpointStage; 
        Game.Core.resetGame();
        Game.Core.gameLoop();
    },
    resetGame: function() {
        const S = Game.State;
        const player = S.player;
        player.x = 20;
        player.y = S.canvas.height - 40 - player.height;
        player.dx = 0;
        player.dy = 0;
        player.onGround = true;
        player.standingOnPlatform = null;
        player.isCrouching = false;
        player.canDropDown = true;
        player.platformToDropThrough = null;
        player.isHit = false;
        player.hitTimer = 0;
        player.powerUp = null;
        player.powerUpCooldown = 0;
        player.isAttacking = false;
        player.attackTimer = 0;
        player.isBlocking = false;
        player.direction = 'right';
        player.maxHp = 1;
        player.hp = S.debugModeActive ? 99 : 1;
        S.score = 0;
        S.scoreDisplay.textContent = S.score;
        S.stageDisplay.textContent = S.stage;
        S.gameOver = false;
        S.isTransitioning = false;
        S.landedYLevels = new Set();
        Game.Level.generatePlatforms();
        Game.Level.generatePowerUps();
        if(S.platforms[0]) S.landedYLevels.add(S.platforms[0].y);
    },
    handleStageTransition: function() {
        const S = Game.State;
        const scrollSpeed = 5;
        const targetY = S.canvas.height - S.goalPlatform.height;
        S.platforms.forEach(p => p.y += scrollSpeed);
        S.powerUps.forEach(p => p.y += scrollSpeed);
        S.player.y += scrollSpeed;
        S.enemies.forEach(e => e.y += scrollSpeed);
        S.decorations.forEach(d => d.y += scrollSpeed);
        if (S.goalPlatform.y >= targetY) {
            const finalShift = targetY - S.goalPlatform.y;
            S.platforms.forEach(p => p.y += finalShift);
            S.powerUps.forEach(p => p.y += finalShift);
            S.player.y += finalShift;
            S.isTransitioning = false;
            S.stage++;
            if ((S.stage - 1) > 0 && (S.stage - 1) % 10 === 0) {
                S.checkpointStage = S.stage;
            }
            S.stageDisplay.textContent = S.stage;
            const previousTopPlatforms = S.platforms.filter(p => p.type === 'top');
            Game.Level.generatePlatforms(previousTopPlatforms);
            Game.Level.generatePowerUps();
            const startPlatform = S.platforms[0];
            S.player.y = startPlatform.y - S.player.height;
            S.player.x = startPlatform.x + (startPlatform.width / 2) - (S.player.width / 2);
            S.player.onGround = true;
            S.player.dy = 0;
            S.player.dx = 0;
            S.landedYLevels.clear();
            S.landedYLevels.add(startPlatform.y);
        }
    }
});

Object.assign(Game.Constants, {
    GRAVITY: 0.5, JUMP_POWER: -12, ENEMY_TURN_DELAY: 500, PLATFORM_HEIGHT: 20, VERTICAL_GAP: 120,
    AWAN_HANTU_DETECTION_X_BASE: 60, AWAN_HANTU_DETECTION_Y: 50, AWAN_HANTU_PAUSE_DURATION: 30, AWAN_HANTU_DASH_SPEED: 8,
    EYE_SWEEP_RANGE: 4, ICICLE_SHAKE_DURATION: 40, ICICLE_FALL_SPEED: 7, ICICLE_WAIT_DURATION: 120, ICICLE_DETECTION_RANGE: 60,
    BAT_WAKE_DURATION: 15, BAT_FLIGHT_RANGE: 90, BAT_FLIGHT_SPEED: 2, BAT_DIP_HEIGHT: 70, BAT_FLIGHT_HEIGHT: 40, BAT_PATROL_END_DELAY: 120,
    BAT_DETECTION_RANGE_X: 400, BAT_ATTACK_RANGE_X: 95, BAT_DETECTION_RANGE_Y: 100, GROUND_MONSTER_ATTACK_RANGE: 120,
    ICE_PLATFORM_SHAKE_DURATION: 60, ICE_SHARD_LIFETIME: 90, ICE_SHARD_BLINK_RATE: 8, BLOCK_WIDTH: 40, LEVEL_SLOTS: 10,
    GAP_PROBABILITY: 0.35, MOVING_PLATFORM_PROB: 0.25, ICY_PLATFORM_PROB: 0.20, ICE_FRICTION: 0.98,
});
Object.assign(Game.State, {
    canvas: document.getElementById('game-canvas'),
    ctx: document.getElementById('game-canvas').getContext('2d'),
    startMenu: document.getElementById('start-menu'),
    startButton: document.getElementById('start-button'),
    gameOverMenu: document.getElementById('game-over-menu'),
    restartButton: document.getElementById('restart-button'),
    continueButton: document.getElementById('continue-button'),
    hud: document.getElementById('hud'),
    scoreDisplay: document.getElementById('score'),
    hpDisplay: document.getElementById('hp-hearts'),
    finalScoreDisplay: document.getElementById('final-score'),
    stageDisplay: document.getElementById('stage'),
    finalStageDisplay: document.getElementById('final-stage'),
    resetPlatformsButton: document.getElementById('reset-platforms-button'),
    stagePresetButtons: document.querySelectorAll('.stage-presets button'),
    characterSelectors: document.querySelectorAll('.char-select'),
    decorationSlider: document.getElementById('decoration-slider'),
    decorationValue: document.getElementById('decoration-value'),
    enemySelectionButtons: document.querySelectorAll('#enemy-selection button'),
    debugPlayerX: document.getElementById('debug-player-x'),
    debugPlayerY: document.getElementById('debug-player-y'),
    debugPlayerDX: document.getElementById('debug-player-dx'),
    debugPlayerDY: document.getElementById('debug-player-dy'),
    debugPlayerOnGround: document.getElementById('debug-player-onground'),
    debugCollision: document.getElementById('debug-collision'),
    mainContainer: document.querySelector('.main-container'),
    instructionsMenu: document.getElementById('instructions-menu'),
    instructionsButton: document.getElementById('instructions-button'),
    backToStartMenuButton: document.getElementById('back-to-start-menu-button'),
    debugCodeMenu: document.getElementById('debug-code-menu'),
    debugCodeInput: document.getElementById('debug-code-input'),
    debugCodeSubmit: document.getElementById('debug-code-submit'),
    nameInputMenu: document.getElementById('name-input-menu'),
    nameInputField: document.getElementById('name-input-field'),
    nameInputSubmit: document.getElementById('name-input-submit'),
    startHighscoreDisplay: document.getElementById('start-highscore-display'),
    refreshHighscoreBtn: document.getElementById('refresh-highscore-btn'),
    score: 0,
    gameOver: false,
    stage: 1,
    checkpointStage: 1,
    isTransitioning: false,
    landedYLevels: new Set(),
    globalAnimationTick: 0,
    selectedCharacter: 'ESKIMO',
    testEnemyType: 'GROUND_MONSTER',
    crumblingPlatformCandidate: null,
    crumbleCounter: 0,
    lastHangingEnemyType: 'BAT',
    userId: null,
    highScores: [],
    debugModeActive: false,
    secretCode: 'MTk2OA==',
    firebaseReady: false,
    player: {
        width: 30, height: 30, x: 0, y: 0, dx: 0, dy: 0,
        hp: 1, maxHp: 1,
        onGround: false, standingOnPlatform: null, isCrouching: false,
        canDropDown: true, platformToDropThrough: null,
        isHit: false, 
        hitTimer: 0,
        powerUp: null,
        powerUpCooldown: 0,
        direction: 'right',
        isAttacking: false,
        attackTimer: 0,
        isBlocking: false,
    },
    enemies: [],
    platforms: [],
    projectiles: [],
    powerUps: [],
    goalPlatform: null,
    decorations: [],
    showcaseCharacters: [],
    playerSpeed: 3,
    friction: 0.97,
    enemySpeed: 1,
    jumpDelay: 500,
    canJump: true,
    decorationProbability: 0.50
});

Object.assign(Game.Assets, {
    ESKIMO: {
        size: 30,
        drawOrder: ['leftLeg', 'rightLeg', 'leftArm', 'rightArm', 'torso', 'face', 'hood_main', 'hood_crouch', 'hood_trim', 'eye1', 'eye1_crouch', 'eye2', 'eye2_crouch'],
        parts: {
            hood_main: { shape: 'rect', color: '#8B4513', x: 2, y: 0, width: 26, height: 28, condition: (anim) => !anim.isCrouching },
            hood_crouch: { shape: 'rect', color: '#8B4513', x: 2, y: 6, width: 26, height: 22, condition: (anim) => anim.isCrouching },
            hood_trim: { shape: 'rect', color: '#4682B4', x: 0, y: 22, width: 30, height: 5 },
            face: { shape: 'rect', color: '#FFDAB9', x: 7, y: 5, width: 16, height: 12, condition: (anim) => !anim.isCrouching },
            face_crouch: { shape: 'rect', color: '#FFDAB9', x: 7, y: 11, width: 16, height: 6, condition: (anim) => anim.isCrouching },
            eye1: { shape: 'rect', color: '#000000', x: 10, y: 10, width: 3, height: 3, condition: (anim) => !anim.isCrouching },
            eye1_crouch: { shape: 'rect', color: '#000000', x: 10, y: 13, width: 3, height: 2, condition: (anim) => anim.isCrouching },
            eye2: { shape: 'rect', color: '#000000', x: 17, y: 10, width: 3, height: 3, condition: (anim) => !anim.isCrouching },
            eye2_crouch: { shape: 'rect', color: '#000000', x: 17, y: 13, width: 3, height: 2, condition: (anim) => anim.isCrouching },
            leftArm: { shape: 'rect', color: '#8B4513', x: -2, y: 15, width: 4, height: 8, animation: { property: 'y', speed: 0.2, amplitude: 1.5, condition: (anim) => anim.isMoving } },
            rightArm: { shape: 'rect', color: '#8B4513', x: 28, y: 15, width: 4, height: 8, animation: { property: 'y', speed: 0.2, amplitude: -1.5, condition: (anim) => anim.isMoving } },
            leftLeg: { shape: 'rect', color: '#8B4513', x: 5, y: 28, width: 8, height: 5 },
            rightLeg: { shape: 'rect', color: '#8B4513', x: 17, y: 28, width: 8, height: 5 },
        }
    },
    ESKIMO_FEMALE: {
        size: 30,
        drawOrder: ['leftLeg', 'rightLeg', 'torso', 'leftArm', 'rightArm', 'face', 'hood_main', 'hood_crouch', 'hood_trim', 'eye1', 'eye1_crouch', 'eye2', 'eye2_crouch'],
        parts: {
            hood_main: { shape: 'rect', color: '#DA70D6', x: 2, y: 0, width: 26, height: 28, condition: (anim) => !anim.isCrouching },
            hood_crouch: { shape: 'rect', color: '#DA70D6', x: 2, y: 6, width: 26, height: 22, condition: (anim) => anim.isCrouching },
            hood_trim: { shape: 'rect', color: '#FF69B4', x: 0, y: 22, width: 30, height: 5 },
            face: { shape: 'rect', color: '#FFDAB9', x: 7, y: 5, width: 16, height: 12, condition: (anim) => !anim.isCrouching },
            face_crouch: { shape: 'rect', color: '#FFDAB9', x: 7, y: 11, width: 16, height: 6, condition: (anim) => anim.isCrouching },
            eye1: { shape: 'rect', color: '#000000', x: 10, y: 10, width: 3, height: 4, condition: (anim) => !anim.isCrouching },
            eye1_crouch: { shape: 'rect', color: '#000000', x: 10, y: 13, width: 3, height: 2, condition: (anim) => anim.isCrouching },
            eye2: { shape: 'rect', color: '#000000', x: 17, y: 10, width: 3, height: 4, condition: (anim) => !anim.isCrouching },
            eye2_crouch: { shape: 'rect', color: '#000000', x: 17, y: 13, width: 3, height: 2, condition: (anim) => anim.isCrouching },
            leftArm: { shape: 'rect', color: '#DA70D6', x: -2, y: 15, width: 4, height: 8, animation: { property: 'y', speed: 0.2, amplitude: 1.5, condition: (anim) => anim.isMoving } },
            rightArm: { shape: 'rect', color: '#DA70D6', x: 28, y: 15, width: 4, height: 8, animation: { property: 'y', speed: 0.2, amplitude: -1.5, condition: (anim) => anim.isMoving } },
            leftLeg: { shape: 'rect', color: '#DA70D6', x: 5, y: 28, width: 8, height: 5 },
            rightLeg: { shape: 'rect', color: '#DA70D6', x: 17, y: 28, width: 8, height: 5 },
        }
    },
    PENGUIN: {
        size: 30,
        drawOrder: ['body', 'body_crouch', 'belly', 'belly_crouch', 'leftWing', 'rightWing', 'beak', 'leftEye', 'rightEye', 'leftPupil', 'rightPupil', 'leftFoot', 'rightFoot'],
        parts: {
            body: { shape: 'ellipse', color: '#000000', x: 0, y: 1, width: 30, height: 28, condition: (anim) => !anim.isCrouching },
            body_crouch: { shape: 'ellipse', color: '#000000', x: 0, y: 7, width: 30, height: 22, condition: (anim) => anim.isCrouching },
            belly: { shape: 'ellipse', color: '#FFFFFF', x: 7, y: 3, width: 16, height: 20, condition: (anim) => !anim.isCrouching },
            belly_crouch: { shape: 'ellipse', color: '#FFFFFF', x: 7, y: 9, width: 16, height: 14, condition: (anim) => anim.isCrouching },
            leftWing: { shape: 'path', color: '#000000', points: [[2, 10], [-3, 20], [4, 22]], condition: (anim) => !anim.isCrouching },
            rightWing: { shape: 'path', color: '#000000', points: [[28, 10], [33, 20], [26, 22]], condition: (anim) => !anim.isCrouching },
            beak: { shape: 'path', color: '#FFA500', points: [[15, 12], [20, 15], [15, 18]] },
            leftEye: { shape: 'rect', color: '#FFFFFF', x: 8, y: 8, width: 5, height: 5 },
            rightEye: { shape: 'rect', color: '#FFFFFF', x: 17, y: 8, width: 5, height: 5 },
            leftPupil: { shape: 'rect', color: '#000000', x: 10, y: 10, width: 2, height: 2 },
            rightPupil: { shape: 'rect', color: '#000000', x: 19, y: 10, width: 2, height: 2 },
            leftFoot: { shape: 'rect', color: '#FFA500', x: 7, y: 28, width: 8, height: 5, animation: { property: 'y', speed: 0.3, amplitude: 1, condition: (anim) => anim.isMoving } },
            rightFoot: { shape: 'rect', color: '#FFA500', x: 15, y: 28, width: 8, height: 5, animation: { property: 'y', speed: 0.3, amplitude: -1, condition: (anim) => anim.isMoving } },
        }
    },
    TERMINATOR: {
        size: 60,
        drawOrder: ["Kaki", "Badan", "Tangan", "Kepala", "mata1"],
        parts: {
            Kepala: { shape: 'rect', color: "#f08d75", x: 5, y: -23, width: 20, height: 20 },
            mata1: { shape: 'rect', color: "#d91d02", x: 7, y: -18, width: 15, height: 5 },
            Badan: { shape: 'rect', color: "#333333", x: -5, y: -5, width: 40, height: 40 },
            Tangan: { shape: 'rect', color: "#64b86c", x: -10, y: 0, width: 50, height: 15, animation: { property: 'y', speed: 0.1, amplitude: 1 } },
            Kaki: { shape: 'rect', color: "#3d26cf", x: 6, y: 35, width: 18, height: 20 },
        }
    },
    HAMMER: {
        drawOrder: ['handle', 'head'],
        parts: {
            handle: { shape: 'rect', color: '#8B4513', x: 10, y: 10, width: 5, height: 15 },
            head: { shape: 'rect', color: '#C0C0C0', x: 0, y: 0, width: 25, height: 10 }
        }
    },
    SHIELD: {
        drawOrder: ['face', 'trim'],
        parts: {
            face: { shape: 'path', color: '#4682B4', points: [[0,0], [25,0], [25,20], [12.5, 30], [0, 20]] },
            trim: { shape: 'rect', color: '#C0C0C0', x: 0, y: 0, width: 25, height: 3 }
        }
    },
    SHIELD_SIDE: {
        drawOrder: ['edge', 'face'],
        parts: {
            edge: { shape: 'rect', color: '#C0C0C0', x: 0, y: 0, width: 4, height: 25 },
            face: { shape: 'rect', color: '#4682B4', x: 4, y: 0, width: 3, height: 25 }
        }
    },
    PROJECTILE: {
        drawOrder: ['body'],
        parts: {
            body: { shape: 'rect', color: '#bdeeff', x: 0, y: 0, width: 8, height: 8 }
        }
    },
    // ... (All other assets will be defined here in the same format)
});

	Object.assign(Game.Player, {
    getPointsPerLevel: function() {
        const stage = Game.State.stage;
        if (stage < 5) return 10;
        return 20 + Math.floor((stage - 5) / 5) * 10;
    },
    handlePlayerInput: function() {
        const player = Game.State.player;
        const stage = Game.State.stage;
        const keys = Game.Controls.keys;
        const C = Game.Constants;
        if (player.isAttacking) {
            player.dx = 0;
        } else {
            if (stage === 101) {
                player.dx = 0;
                return;
            }
            player.isCrouching = (keys.down && player.onGround);
            const onIce = player.onGround && player.standingOnPlatform && player.standingOnPlatform.subType === 'icy';
            if (keys.left) {
                player.direction = 'left';
                if (onIce) { if (player.dx > 0) player.dx -= 0.4; player.dx = Math.max(player.dx - 0.2, -Game.State.playerSpeed); } 
                else { player.dx = -Game.State.playerSpeed; }
            } else if (keys.right) {
                player.direction = 'right';
                if (onIce) { if (player.dx < 0) player.dx += 0.4; player.dx = Math.min(player.dx + 0.2, Game.State.playerSpeed); } 
                else { player.dx = Game.State.playerSpeed; }
            } else if (player.onGround) {
                if (onIce) { player.dx *= C.ICE_FRICTION; } 
                else { player.dx = 0; }
            }
            if (Math.abs(player.dx) < 0.1) player.dx = 0;
            if ((keys.up || keys.a) && player.onGround && Game.State.canJump) {
                if (player.isCrouching && player.standingOnPlatform && player.standingOnPlatform.type !== 'base' && player.canDropDown) {
                    player.dy = -2;
                    player.onGround = false;
                    player.platformToDropThrough = player.standingOnPlatform;
                    player.canDropDown = false;
                    setTimeout(() => { player.canDropDown = true; }, 300);
                } else if (!player.isCrouching) {
                    player.dy = Game.Constants.JUMP_POWER;
                    player.onGround = false;
                    Game.State.canJump = false;
                    setTimeout(() => { Game.State.canJump = true; }, Game.State.jumpDelay);
                }
            }
        }
        if (keys.b && player.powerUp) {
            if (player.powerUp.type === 'HAMMER' && player.attackTimer <= 0) {
                player.isAttacking = true;
                player.attackTimer = 30;
                player.dx = 0;
            } else if (player.powerUp.type === 'SHIELD') {
                player.isBlocking = true;
                if (player.onGround && (keys.left || keys.right) && player.dy === 0) {
                    player.dy = -2.5;
                    player.onGround = false;
                }
            }
        } else {
            player.isBlocking = false;
        }
    },
    updateActions: function() {
        const player = Game.State.player;
        const S = Game.State;
        if (player.attackTimer > 0) {
            player.attackTimer--;
            if (player.isAttacking && player.attackTimer === 25) {
                const attackOffset = 5;
                const attackWidth = 25;
                const attackX = player.direction === 'right' ? player.x + player.width + attackOffset : player.x - attackWidth - attackOffset;
                const attackY = player.y;
                const attackHeight = player.height;
                for (let i = S.enemies.length - 1; i >= 0; i--) {
                    const enemy = S.enemies[i];
                    if (attackX < enemy.x + enemy.width && attackX + attackWidth > enemy.x &&
                        attackY < enemy.y + enemy.height && attackY + attackHeight > enemy.y) {
                        if (enemy.type === 'GROUND_MONSTER' || enemy.type === 'BAT') {
                            S.enemies.splice(i, 1);
                        }
                    }
                }
            }
            if (player.attackTimer === 0) {
                player.isAttacking = false;
            }
        }
    },
    updatePlayerPosition: function() {
        const player = Game.State.player;
        if (Game.State.stage === 101) return;
        player.dy += Game.Constants.GRAVITY;
        player.x += player.dx;
        player.y += player.dy;
        if (player.x + player.width < 0) { player.x = Game.State.canvas.width; } 
        else if (player.x > Game.State.canvas.width) { player.x = -player.width; }
    },
    checkPlayerCollisions: function() {
        const player = Game.State.player;
        const S = Game.State;
        player.onGround = false;
        player.standingOnPlatform = null;
        for (const plat of S.platforms) {
            if(player.platformToDropThrough === plat || plat.isFalling) continue;
            if (player.x + player.width > plat.x && player.x < plat.x + plat.width) {
                if (player.dy >= 0 && player.y + player.height >= plat.y && (player.y + player.height - player.dy) <= plat.y) {
                    player.dy = 0;
                    player.onGround = true;
                    player.y = plat.y - player.height;
                    player.standingOnPlatform = plat;
                    if (plat.subType === 'moving') player.x += plat.dx;
                    if (!S.landedYLevels.has(plat.y) && ![101, 102].includes(S.stage) && !S.debugModeActive) {
                        S.score += Game.Player.getPointsPerLevel();
                        S.scoreDisplay.textContent = S.score;
                        S.landedYLevels.add(plat.y);
                    }
                }
                if (player.dy < 0 && player.y <= (plat.y + plat.height) && (player.y - player.dy) > (plat.y + plat.height)) {
                    if (![101, 102].includes(S.stage)) { player.dy = 0; }
                    if (plat.subType === 'crumbling') { plat.isFalling = true; }
                }
            }
        }
        for (let i = S.enemies.length - 1; i >= 0; i--) {
            const enemy = S.enemies[i];
            if (!enemy) continue;
            const isColliding = player.x + player.width > enemy.x && player.x < enemy.x + enemy.width && player.y + player.height > enemy.y && player.y < enemy.y + enemy.height;
            if (isColliding) {
                if ((enemy.type === 'ICICLE' && enemy.state === 'STUCK')) {
                    if (player.dx > 0) player.x = enemy.x - player.width; else if (player.dx < 0) player.x = enemy.x + enemy.width;
                    player.dx = 0;
                    continue;
                }
                if (enemy.type === 'MIMIC_ICE' && enemy.state !== 'BREAKING') {
                    if (player.dy >= 0 && (player.y + player.height - player.dy) <= enemy.y) {
                         player.dy = 0;
                         player.onGround = true;
                         player.y = enemy.y - player.height;
                         player.standingOnPlatform = enemy;
                         if (enemy.state === 'IDLE') {
                             enemy.state = 'SHAKING';
                             enemy.shakeTimer = Game.Constants.ICE_PLATFORM_SHAKE_DURATION;
                         }
                    } else if (player.dy < 0 && (player.y - player.dy) > (enemy.y + enemy.height)) {
                        player.dy *= -0.5;
                        if (!enemy.hitCooldown) {
                             enemy.hits = (enemy.hits || 0) + 1;
                             enemy.hitCooldown = true;
                             setTimeout(() => { if(enemy) enemy.hitCooldown = false; }, 200);
                             if (enemy.hits >= 3) {
                                 enemy.state = 'BREAKING';
                             }
                        }
                    }
                    continue; 
                }
                const isFrontalCollision = (player.direction === 'right' && enemy.x >= player.x) || (player.direction === 'left' && enemy.x <= player.x);
                if (player.isBlocking && isFrontalCollision) {
                    player.dx += player.direction === 'right' ? -2 : 2; player.dy = -4; player.onGround = false; 
                } else if (!player.isHit) {
                    player.hp--;
                    player.isHit = true;
                    player.hitTimer = 90;
                    player.dy = -5;
                    if (player.hp < player.maxHp) {
                        player.powerUp = null;
                        player.maxHp = 1;
                    }
                    if (player.hp <= 0 && !S.debugModeActive) {
                        S.gameOver = true;
                    }
                }
            }
        }
        for (let i = S.projectiles.length - 1; i >= 0; i--) {
            const proj = S.projectiles[i];
            if (player.x + player.width > proj.x && player.x < proj.x + proj.width && player.y + player.height > proj.y && player.y < proj.y + proj.height) {
                 const isFrontalCollision = (player.direction === 'right' && proj.dx < 0) || (player.direction === 'left' && proj.dx > 0);
                 if (player.isBlocking && isFrontalCollision) {
                     S.projectiles.splice(i, 1);
                     player.dx += player.direction === 'right' ? -2 : 2; player.dy = -4; player.onGround = false; 
                 } else if (!player.isHit) {
                     S.projectiles.splice(i, 1);
                     player.hp--;
                     player.isHit = true;
                     player.hitTimer = 90;
                     player.dy = -5;
                     if (player.hp < player.maxHp) {
                         player.powerUp = null;
                         player.maxHp = 1;
                     }
                     if (player.hp <= 0 && !S.debugModeActive) {
                         S.gameOver = true;
                     }
                 }
            }
        }
        if (player.powerUpCooldown === 0) {
            for (let i = S.powerUps.length - 1; i >= 0; i--) {
                const p = S.powerUps[i];
                if (player.x < p.x + p.width && player.x + player.width > p.x && player.y < p.y + p.height && player.y + player.height > p.y) {
                    const currentPowerUp = player.powerUp;
                    player.powerUp = p;
                    player.hp = 2;
                    player.maxHp = 2;
                    player.powerUpCooldown = 30;
                    if (currentPowerUp) {
                        S.powerUps[i] = currentPowerUp;
                        currentPowerUp.x = p.x;
                        currentPowerUp.y = p.y;
                    } else {
                        S.powerUps.splice(i, 1);
                    }
                    break;
                }
            }
        }
    }
});

	Object.assign(Game.Enemies, {
    generateEnemies: function() {
        const S = Game.State;
        const C = Game.Constants;
        const stage = S.stage;
        S.enemies = [];
        S.projectiles = [];
        const platforms = S.platforms;
        const goalPlatform = S.goalPlatform;
        const spawnBuffer = 20;

        if (stage >= 101) {
            const p1 = platforms.find(p => p.y < 400 && p.x === 0);
            const p2 = platforms.find(p => p.y < 400 && p.x > 100 && p.x < 200);
            const p3 = platforms.find(p => p.y < 400 && p.x > 200);
            const p6 = platforms.find(p => p.y < 200 && p.x > 100 && p.x < 200);

            if(stage === 102) {
                const selectedEnemyType = S.testEnemyType;
                const p_mid = platforms.find(p=>p.y < 450 && p.y > 400);
                const p_top = platforms.find(p=>p.y < 300 && p.y > 200);
                if(p_mid && selectedEnemyType === 'GROUND_MONSTER') S.enemies.push({ type: 'GROUND_MONSTER', width: 25, height: 25, x: p_mid.x + (p_mid.width/2) - 12.5, y: p_mid.y - 25, dx: S.enemySpeed, platform: p_mid, isTurning: false, animationTick: 0, facing: 'right' });
                if(p_mid && selectedEnemyType === 'AWAN_HANTU') { const baseX = p_mid.x + (p_mid.width/2) - 17.5; const baseY = p_mid.y - 40; S.enemies.push({ type: 'AWAN_HANTU', width: 35, height: 25, x: baseX, y: baseY, originalX: baseX, originalY: baseY, baseY: baseY, dx: 0, platform: p_mid, animationAngle: 0, eyeAngle: 0, state: 'SCANNING' });}
                if(p_top && selectedEnemyType === 'ICICLE') S.enemies.push({ type: 'ICICLE', width: 15, height: 30, x: p_top.x + (p_top.width/2), y: p_top.y + C.PLATFORM_HEIGHT, originalX: p_top.x + (p_top.width/2), originalY: p_top.y + C.PLATFORM_HEIGHT, state: 'IDLE' });
                if(p_top && selectedEnemyType === 'BAT') S.enemies.push({type: 'BAT', width: 30, height: 20, x: p_top.x + (p_top.width/2), y: p_top.y + C.PLATFORM_HEIGHT, originalX: p_top.x + (p_top.width/2), originalY: p_top.y + C.PLATFORM_HEIGHT, state: 'HANGING' });
                return;
            }

            if(p1) S.enemies.push({ type: 'GROUND_MONSTER', width: 25, height: 25, x: p1.x + (p1.width / 2) - 12.5, y: p1.y - 25, dx: 0, platform: p1, isTurning: false, animationTick: 0, facing: 'right', animationTimer: 0 });
            if(p2) { const baseX = p2.x + (p2.width / 2) - 17.5; const baseY = p2.y - 40; S.enemies.push({ type: 'AWAN_HANTU', width: 35, height: 25, x: baseX, y: baseY, originalX: baseX, originalY: baseY, baseY: baseY, dx: 0, platform: p2, animationAngle: Math.random() * Math.PI * 2, eyeAngle: 0, state: 'SCANNING' }); }
            if(p3) { const icicleX = p3.x + (p3.width / 2); const icicleY = p3.y + C.PLATFORM_HEIGHT; S.enemies.push({ type: 'ICICLE', width: 15, height: 30, x: icicleX, y: icicleY, originalX: icicleX, originalY: icicleY, state: 'IDLE' }); }
            if(p6) { const batX = p6.x + (p6.width / 2); const batY = p6.y + C.PLATFORM_HEIGHT; S.enemies.push({type: 'BAT', width: 30, height: 20, x: batX, y: batY, originalX: batX, originalY: batY, state: 'HANGING' }); }
            return; 
        }

        const spawnablePlatforms = platforms.filter(p => p.type !== 'base' && p.type !== 'top' && p !== goalPlatform && (p.subType === 'normal' || p.subType === 'icy'));
        if (spawnablePlatforms.length === 0) return;

        const lowerTierPlatforms = spawnablePlatforms.filter(p => p.y > 100);
        let numEnemies = stage >= 15 ? 3 : stage >= 7 ? 2 : stage >= 3 ? 1 : 0;

        if (numEnemies > 0 && lowerTierPlatforms.length > 0) {
            const platformYLevels = [...new Set(lowerTierPlatforms.map(p => p.y))];
            const shuffledYLevels = platformYLevels.sort(() => 0.5 - Math.random());
            const selectedYLevels = shuffledYLevels.slice(0, numEnemies);

            for (const yLevel of selectedYLevels) {
                const platformsAtLevel = lowerTierPlatforms.filter(p => p.y === yLevel);
                const platform = platformsAtLevel[Math.floor(Math.random() * platformsAtLevel.length)];
                const minSpawnX = Math.max(spawnBuffer, platform.x);
                const maxSpawnX = Math.min(S.canvas.width - spawnBuffer - 25, platform.x + platform.width - 25);
                if (maxSpawnX > minSpawnX) {
                    const spawnX = minSpawnX + Math.random() * (maxSpawnX - minSpawnX);
                    const initialDirection = Math.random() < 0.5 ? 1 : -1;
                    const monster = { type: 'GROUND_MONSTER', width: 25, height: 25, x: spawnX, y: platform.y - 25, dx: S.enemySpeed * initialDirection, platform: platform, isTurning: false, animationTick: 0, facing: initialDirection > 0 ? 'right' : 'left' };
                    if (stage >= 20) { monster.attackCooldown = (stage > 30) ? (90 + Math.random() * 40) : (120 + Math.random() * 60); monster.isAttacking = false; }
                    S.enemies.push(monster);
                }
            }
        }

        let awanHantuChance = (stage > 0 && stage % 10 === 0) ? 1.0 : (stage >= 21) ? 0.25 : 0;
        if (Math.random() < awanHantuChance && platforms.length > 5) {
            const topTierPlatforms = platforms.filter(p => p.y < 200 && p.type !== 'top' && (p.subType === 'normal' || p.subType === 'icy'));
            if (topTierPlatforms.length > 0) {
                const platform = topTierPlatforms[Math.floor(Math.random() * topTierPlatforms.length)];
                const baseX = platform.x + (platform.width / 2) - 17.5; const baseY = platform.y - 40;
                S.enemies.push({ type: 'AWAN_HANTU', width: 35, height: 25, x: baseX, y: baseY, originalX: baseX, originalY: baseY, baseY: baseY, dx: 0, platform: platform, animationAngle: Math.random() * Math.PI * 2, eyeAngle: 0, state: 'SCANNING' });
            }
        }

        if (stage >= 5) {
            const spawnChance = 0.05 + (stage - 5) * 0.002;
            spawnablePlatforms.forEach(platform => {
                if (platform.y > 50 && platform.y < S.canvas.height - 150 && Math.random() < spawnChance) {
                    if(S.lastHangingEnemyType === 'BAT') {
                        const minX = Math.max(spawnBuffer, platform.x);
                        const maxX = Math.min(S.canvas.width - spawnBuffer - 15, platform.x + platform.width - 15);
                        if (maxX > minX) {
                            const icicleX = minX + Math.random() * (maxX - minX);
                            S.enemies.push({ type: 'ICICLE', width: 15, height: 30, x: icicleX, y: platform.y + C.PLATFORM_HEIGHT, originalX: icicleX, originalY: platform.y + C.PLATFORM_HEIGHT, state: 'IDLE' });
                            S.lastHangingEnemyType = 'ICICLE';
                        }
                    } else {
                        const minX = Math.max(spawnBuffer, platform.x);
                        const maxX = Math.min(S.canvas.width - spawnBuffer - 30, platform.x + platform.width - 30);
                         if (maxX > minX) {
                            const batX = minX + Math.random() * (maxX - minX);
                            S.enemies.push({type: 'BAT', width: 30, height: 20, x: batX, y: platform.y + C.PLATFORM_HEIGHT, originalX: batX, originalY: platform.y + C.PLATFORM_HEIGHT, state: 'HANGING' });
                            S.lastHangingEnemyType = 'BAT';
                        }
                    }
                }
            });
        }
    },
    updateEnemies: function() {
        const C = Game.Constants; 
        const S = Game.State;
        for (let i = S.enemies.length - 1; i >= 0; i--) {
            const enemy = S.enemies[i];
            if (!enemy) continue;
            if (enemy.type.includes('GROUND_MONSTER')) { 
                if (!enemy.isAttacking && !enemy.isTurning && enemy.dx !== 0) { 
                    let shouldTurn = false;
                    const nextX = enemy.x + enemy.dx;
                    if (nextX <= 0 || nextX + enemy.width >= S.canvas.width) {
                        shouldTurn = true;
                    }
                    if (!shouldTurn) {
                        for (const other of S.enemies) {
                            if (other.type === 'ICICLE' && other.state === 'STUCK') {
                                if (nextX < other.x + other.width && nextX + enemy.width > other.x &&
                                    enemy.y < other.y + other.height && enemy.y + enemy.height > other.y) {
                                    shouldTurn = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (!shouldTurn && S.player.isBlocking) {
                        const playerIsFacingEnemy = (S.player.direction === 'right' && enemy.x > S.player.x) || (S.player.direction === 'left' && enemy.x < S.player.x);
                        if (playerIsFacingEnemy) {
                            if (nextX < S.player.x + S.player.width &&
                                nextX + enemy.width > S.player.x &&
                                enemy.y < S.player.y + S.player.height &&
                                enemy.y + enemy.height > S.player.y)
                            {
                                shouldTurn = true;
                            }
                        }
                    }
                    if (!shouldTurn) {
                        const probeX = enemy.dx > 0 ? nextX + enemy.width : nextX;
                        const probeY = enemy.y + enemy.height + 5;
                        const groundExists = S.platforms.some(p => 
                            !p.isFalling && 
                            probeX >= p.x && 
                            probeX < (p.x + p.width) &&
                            probeY > p.y &&
                            probeY < (p.y + p.height + 10)
                        );
                        if (!groundExists) {
                            shouldTurn = true;
                        }
                    }
                    if (shouldTurn) {
                        enemy.isTurning = true;
                        enemy.facing = enemy.dx > 0 ? 'left' : 'right';
                        enemy.dx = 0;
                        setTimeout(() => {
                            if (enemy) {
                                enemy.dx = enemy.facing === 'right' ? S.enemySpeed : -S.enemySpeed;
                                enemy.isTurning = false;
                            }
                        }, C.ENEMY_TURN_DELAY);
                    } else {
                        enemy.x = nextX;
                        enemy.animationTick++;
                    }
                }
                if (enemy.isAttacking && (S.stage < 20 && S.stage !== 102)) {
                    enemy.isAttacking = false; 
                    enemy.dx = enemy.facing === 'right' ? S.enemySpeed : -S.enemySpeed;
                }
                const distanceToPlayer = Math.abs((S.player.x + S.player.width / 2) - (enemy.x + enemy.width / 2));
                const onSamePlatform = S.player.standingOnPlatform === enemy.platform;
                const isPlayerInFront = (enemy.facing === 'right' && S.player.x > enemy.x) || (enemy.facing === 'left' && S.player.x < enemy.x);
                if ((S.stage >= 20 || S.stage === 102) && onSamePlatform && isPlayerInFront && distanceToPlayer < C.GROUND_MONSTER_ATTACK_RANGE) {
                    if (!enemy.isAttacking) {
                        enemy.isAttacking = true;
                        enemy.dx = 0;
                    }
                    if (enemy.attackCooldown > 0) enemy.attackCooldown--;
                    if (enemy.attackCooldown <= 0) {
                        const projectileX = enemy.facing === 'right' ? enemy.x + enemy.width : enemy.x;
                        const projectileY = enemy.y + 17;
                        const projectileDX = enemy.facing === 'right' ? 4 : -4;
                        S.projectiles.push({ type:'PROJECTILE', x: projectileX, y: projectileY, dx: projectileDX, width: 8, height: 8 });
                        enemy.attackCooldown = 120;
                    }
                } else {
                    if(enemy.isAttacking) {
                        enemy.isAttacking = false;
                        enemy.dx = enemy.facing === 'right' ? S.enemySpeed : -S.enemySpeed;
                    }
                }
            } else if (enemy.type.includes('AWAN_HANTU')) { 
                const isBoss = enemy.type.includes('BOSS_');
                switch (enemy.state) { 
                    case 'SCANNING': 
                        enemy.animationAngle += 0.05; 
                        enemy.y = enemy.baseY + Math.sin(enemy.animationAngle) * 5; 
                        enemy.eyeAngle += 0.03; 
                        const detectionRangeX = C.AWAN_HANTU_DETECTION_X_BASE + (isBoss ? 50 : (Math.floor(S.stage / 10) - 1) * 10);
                        const playerDistX = Math.abs((S.player.x + S.player.width/2) - (enemy.x + enemy.width/2)); 
                        const playerDistY = Math.abs(S.player.y - enemy.y); 
                        const eyeDirection = Math.sin(enemy.eyeAngle); 
                        if (playerDistX < detectionRangeX && playerDistY < C.AWAN_HANTU_DETECTION_Y) { 
                            const isPlayerRight = S.player.x > enemy.x; 
                            if ((isPlayerRight && eyeDirection > 0.3) || (!isPlayerRight && eyeDirection < -0.3)) { 
                                enemy.state = 'PAUSING'; 
                                enemy.detectionTimer = C.AWAN_HANTU_PAUSE_DURATION; 
                                const dashOvershoot = isBoss ? 50 : 0;
                                enemy.dashTargetX = S.player.x + (isPlayerRight ? dashOvershoot : -dashOvershoot);
                            } 
                        } 
                        break; 
                    case 'PAUSING': enemy.detectionTimer--; if (enemy.detectionTimer <= 0) { enemy.state = 'DASHING'; } break; 
                    case 'DASHING': const directionToTarget = Math.sign(enemy.dashTargetX - enemy.x); enemy.x += directionToTarget * C.AWAN_HANTU_DASH_SPEED; if (Math.abs(enemy.x - enemy.dashTargetX) < C.AWAN_HANTU_DASH_SPEED) { enemy.x = enemy.dashTargetX; enemy.state = 'RETURNING'; } break; 
                    case 'RETURNING': const directionToHome = Math.sign(enemy.originalX - enemy.x); enemy.x += directionToHome * (C.AWAN_HANTU_DASH_SPEED / 2); if (Math.abs(enemy.x - enemy.originalX) < (C.AWAN_HANTU_DASH_SPEED / 2)) { enemy.x = enemy.originalX; enemy.state = 'SCANNING'; } break; 
                } 
            } else if (enemy.type.includes('ICICLE')) {
                if (enemy.state === 'STUCK' && enemy.platform && enemy.platform.subType === 'moving') {
                    enemy.x += enemy.platform.dx;
                }
                switch (enemy.state) {
                    case 'IDLE':
                        if (S.stage === 101 || S.stage === 102) {
                            if(!enemy.resetTimer) enemy.resetTimer = 180;
                            enemy.resetTimer--;
                            if(enemy.resetTimer <= 0) {
                                enemy.state = 'SHAKING';
                                enemy.shakeTimer = C.ICICLE_SHAKE_DURATION;
                                delete enemy.resetTimer;
                            }
                        } else if (S.player.onGround && S.player.standingOnPlatform) {
                            const yDist = S.player.standingOnPlatform.y - (enemy.y - C.PLATFORM_HEIGHT);
                            const xDist = Math.abs((S.player.x + S.player.width/2) - (enemy.x + enemy.width/2));
                            if (Math.abs(yDist - C.VERTICAL_GAP) < 10 && xDist < C.ICICLE_DETECTION_RANGE) {
                                enemy.state = 'SHAKING';
                                enemy.shakeTimer = C.ICICLE_SHAKE_DURATION;
                            }
                        }
                        break;
                    case 'SHAKING':
                        enemy.shakeTimer--;
                        enemy.x = enemy.originalX + Math.sin(S.globalAnimationTick * 0.8) * 2;
                        if (enemy.shakeTimer <= 0) { enemy.state = 'FALLING'; enemy.platform = null; }
                        break;
                    case 'FALLING':
                        enemy.y += C.ICICLE_FALL_SPEED;
                        for (const p of S.platforms) {
                            if (p.isFalling) continue;
                            const tipY = enemy.y + enemy.height;
                            if (tipY >= p.y && tipY - C.ICICLE_FALL_SPEED < p.y && enemy.x > p.x && enemy.x < p.x + p.width)
                            {
                                enemy.y = p.y - enemy.height + 8;
                                enemy.state = 'STUCK';
                                enemy.platform = p; // Attach to new platform
                                break; 
                            }
                        }
                        if (enemy.y > S.canvas.height) {
                            S.enemies.splice(i, 1);
                        }
                        break;
                    case 'STUCK': break;
                   }
            } else if (enemy.type.includes('BAT')) { 
                const isBoss = enemy.type.includes('BOSS_');
                const currentFlightRange = isBoss ? C.BAT_FLIGHT_RANGE * 1.5 : C.BAT_FLIGHT_RANGE;
                const xDist = Math.abs((S.player.x + S.player.width/2) - (enemy.x + enemy.width/2));
                const yDist = S.player.y - enemy.y;
                const isPlayerBelow = yDist > 0;
                const playerInDetectionRange = isPlayerBelow && yDist < C.BAT_DETECTION_RANGE_Y && xDist < C.BAT_DETECTION_RANGE_X;
                switch(enemy.state) {
                    case 'HANGING': if (playerInDetectionRange) { enemy.state = 'DETECTED'; } break;
                    case 'DETECTED': if (playerInDetectionRange && xDist < C.BAT_ATTACK_RANGE_X) { enemy.state = 'WAKING'; enemy.wakeTimer = C.BAT_WAKE_DURATION; } else if (!playerInDetectionRange) { enemy.state = 'HANGING'; } break;
                    case 'WAKING': enemy.wakeTimer--; if(enemy.wakeTimer <= 0) { enemy.state = 'FLYING_DIP'; enemy.targetY = enemy.originalY + C.BAT_DIP_HEIGHT; enemy.dx = (S.player.x < enemy.x) ? -C.BAT_FLIGHT_SPEED : C.BAT_FLIGHT_SPEED; } break;
                    case 'FLYING_DIP': enemy.y += (enemy.targetY - enemy.y) * 0.1; enemy.x += enemy.dx; if (Math.abs(enemy.y - enemy.targetY) < 1) { enemy.state = 'ASCENDING'; enemy.targetY = enemy.originalY + C.BAT_FLIGHT_HEIGHT; } break;
                    case 'ASCENDING': enemy.y += (enemy.targetY - enemy.y) * 0.1; enemy.x += enemy.dx; if (Math.abs(enemy.y - enemy.targetY) < 1) { enemy.state = 'FLYING'; } if (enemy.x <= enemy.originalX - currentFlightRange || enemy.x >= enemy.originalX + currentFlightRange) { enemy.dx *= -1; } break;
                    case 'FLYING':
                        if (!enemy.dx) { enemy.dx = C.BAT_FLIGHT_SPEED; }
                        enemy.x += enemy.dx;
                        if (enemy.x <= enemy.originalX - currentFlightRange || enemy.x >= enemy.originalX + currentFlightRange) {
                            enemy.dx *= -1;
                        }
                        if (!playerInDetectionRange) {
                            if (enemy.patrolEndTimer == null) { enemy.patrolEndTimer = C.BAT_PATROL_END_DELAY; }
                            enemy.patrolEndTimer--;
                            if (enemy.patrolEndTimer <= 0) {
                                enemy.state = 'RETURNING_HOME';
                                delete enemy.patrolEndTimer;
                            }
                        } else {
                            if (enemy.patrolEndTimer != null) { delete enemy.patrolEndTimer; }
                        }
                        break;
                    case 'RETURNING_HOME': const distToHome = Math.hypot(enemy.x - enemy.originalX, enemy.y - enemy.originalY); if (distToHome < C.BAT_FLIGHT_SPEED * 2) { enemy.x = enemy.originalX; enemy.y = enemy.originalY; enemy.state = 'HANGING'; } else { const dirX = Math.sign(enemy.originalX - enemy.x); const dirY = Math.sign(enemy.originalY - enemy.y); enemy.x += dirX * C.BAT_FLIGHT_SPEED; enemy.y += dirY * C.BAT_FLIGHT_SPEED; } break;
                } 
            } else if (enemy.type === 'MIMIC_ICE') {
                if (enemy.state === 'SHAKING') {
                    enemy.shakeTimer--;
                    if (enemy.shakeTimer <= 0) {
                        enemy.state = 'BREAKING';
                    }
                } else if (enemy.state === 'BREAKING') {
                    const shardCount = 5;
                    const shardWidth = enemy.width / shardCount;
                    for (let j = 0; j < shardCount; j++) {
                        S.enemies.push({
                            type: 'ICE_SHARD',
                            x: enemy.x + (j * shardWidth), y: enemy.y,
                            width: shardWidth, height: C.PLATFORM_HEIGHT,
                            dx: (Math.random() - 0.5) * 2, dy: Math.random() * -2,
                            lifetime: C.ICE_SHARD_LIFETIME
                        });
                    }
                    S.enemies.splice(i, 1);
                }
            } else if (enemy.type === 'ICE_SHARD') {
                enemy.dy += C.GRAVITY * 0.5;
                enemy.x += enemy.dx;
                enemy.y += enemy.dy;
                enemy.lifetime--;
                if (enemy.lifetime <= 0) {
                    S.enemies.splice(i, 1);
                }
            }
        }
    },
    updateProjectiles: function() {
        const S = Game.State;
        for (let i = S.projectiles.length - 1; i >= 0; i--) {
            const p = S.projectiles[i];
            p.x += p.dx;
            if (p.x < 0 || p.x > S.canvas.width) {
                S.projectiles.splice(i, 1);
            }
        }
    }
});

	Object.assign(Game.Level, {
    parseLayoutToPlatforms: function(layout, y, type = 'normal') {
        const C = Game.Constants;
        const S = Game.State;
        let platforms = [];
        for (let i = 0; i < C.LEVEL_SLOTS; i++) {
            const char = layout[i];
            const x = i * C.BLOCK_WIDTH;
            let commonProps = { y: y, height: C.PLATFORM_HEIGHT, type: type, isFalling: false };

            if ((char === 'G' || char === 'C') && Math.random() < 0.15 && S.stage > 10) {
                 S.enemies.push({ 
                    type: 'MIMIC_ICE', 
                    x: x, y: y, 
                    width: C.BLOCK_WIDTH, height: C.PLATFORM_HEIGHT, 
                    hits: 0, state: 'IDLE', 
                    originalX: x, hitCooldown: false 
                });
                continue; // Jangan jana platform biasa di sini
            }

            if (char === 'B' || char === 'I' || char === 'M') {
                let p = { ...commonProps, x: x, width: C.BLOCK_WIDTH, subType: 'normal' };
                if (char === 'I') p.subType = 'icy';
                if (char === 'M') {
                    p.subType = 'moving';
                    p.originalX = x;
                    let speedMultiplier = 0.8;
                    if (S.stage >= 21 && S.stage <= 30) {
                        speedMultiplier = 1.0 + (S.stage - 21) * 0.05;
                    } else if (S.stage > 30) {
                        speedMultiplier = 1.5;
                    }
                    p.dx = (Math.random() < 0.5 ? 1 : -1) * speedMultiplier;
                }
                platforms.push(p);
            } else if (char === 'C') {
                let crumblingProps = { ...commonProps, width: C.BLOCK_WIDTH, subType: 'crumbling' };
                platforms.push({ ...crumblingProps, x: x, id: Math.random() });
            }
        }
        return platforms;
    },

    generatePlatformRow: function(isFirstRow) {
        const C = Game.Constants;
        const S = Game.State;
        const stage = S.stage;
        let newLayout = Array(C.LEVEL_SLOTS).fill('B');

        if (isFirstRow) {
            const gapStart = 3 + Math.floor(Math.random() * 3);
            newLayout[gapStart] = 'G';
            newLayout[gapStart + 1] = 'G';
            return newLayout;
        }

        let gapProb = C.GAP_PROBABILITY + (stage * 0.005);
        let movingProb = C.MOVING_PLATFORM_PROB + (stage * 0.003);
        let icyProb = C.ICY_PLATFORM_PROB + (stage * 0.005);
        let crumblingInsteadOfGapProb = 0.5;

        if (stage >= 11 && stage <= 20) { crumblingInsteadOfGapProb = 0.75; }
        else if (stage >= 21 && stage <= 30) { movingProb += 0.2; }
        else if (stage > 30) { icyProb += 0.3; }

        const patternRoll = Math.random();
        if (patternRoll < 0.1) {
            const patterns = [['B','I','G','G','B','B','I','I','G','G'],['B','B','B','G','G','G','G','B','B','B'],['B','B','G','G','C','C','G','G','B','B']];
            return patterns[Math.floor(Math.random() * patterns.length)];
        }

        let hasPlacedGap = false;
        for (let j = 1; j < C.LEVEL_SLOTS - 1; j++) {
            if (j === 6 && !hasPlacedGap) {
                const doubleGapType = Math.random() < crumblingInsteadOfGapProb ? 'C' : 'G';
                newLayout[j] = doubleGapType; newLayout[j+1] = doubleGapType;
                j++; hasPlacedGap = true; continue;
            }

            if (!hasPlacedGap && Math.random() < gapProb && j < C.LEVEL_SLOTS - 2) {
                const doubleGapType = Math.random() < crumblingInsteadOfGapProb ? 'C' : 'G';
                newLayout[j] = doubleGapType; newLayout[j+1] = doubleGapType;
                j++; hasPlacedGap = true;
            } else {
                newLayout[j] = (Math.random() < icyProb) ? 'I' : 'B';
            }
        }
        if (!hasPlacedGap) {
            let gapStart = 3 + Math.floor(Math.random() * 3);
            const doubleGapType = Math.random() < crumblingInsteadOfGapProb ? 'C' : 'G';
            newLayout[gapStart] = doubleGapType; newLayout[gapStart + 1] = doubleGapType;
        }

        for (let j = 1; j < C.LEVEL_SLOTS - 2; j++) {
            if (newLayout[j-1] !== 'G' && newLayout[j-1] !== 'C' && newLayout[j+1] !== 'G' && newLayout[j+1] !== 'C' && Math.random() < movingProb) {
                newLayout[j-1] = 'G'; newLayout[j] = 'M'; newLayout[j+1] = 'G';
                j += 2; 
            }
        }

        if (['C', 'M', 'G'].includes(newLayout[0])) newLayout[0] = 'B';
        if (['C', 'M', 'G'].includes(newLayout[C.LEVEL_SLOTS - 1])) newLayout[C.LEVEL_SLOTS - 1] = 'B';
        for (let j = 1; j < C.LEVEL_SLOTS -1; j++) {
             if (['G', 'C'].includes(newLayout[j-1]) && !['G', 'C', 'M'].includes(newLayout[j]) && ['G', 'C'].includes(newLayout[j+1])) {
                  newLayout[j] = newLayout[j-1];
             }
        }

        return newLayout;
    },

    generatePlatforms: function(basePlatformsArg = null) {
        const S = Game.State;
        const C = Game.Constants;

        if ([101, 102].includes(S.stage)) {
            const canvas = S.canvas;
            S.showcaseCharacters = [];
            S.platforms = [];
            const floor = { x: 0, y: canvas.height - 40, width: canvas.width, height: 40, type: 'base' };
            S.platforms.push(floor);

            if (S.stage === 101) {
                const platformWidth = 110; const gapWidth = 35; const verticalGap = 130;
                let y = canvas.height - 40 - verticalGap;
                for (let i = 0; i < 3; i++) {
                    S.platforms.push({ x: 0, y: y, width: platformWidth, height: C.PLATFORM_HEIGHT });
                    S.platforms.push({ x: platformWidth + gapWidth, y: y, width: platformWidth, height: C.PLATFORM_HEIGHT });
                    S.platforms.push({ x: (platformWidth + gapWidth) * 2, y: y, width: platformWidth, height: C.PLATFORM_HEIGHT });
                    y -= verticalGap;
                }
                S.showcaseCharacters.push({ type: 'ESKIMO', x: 120, y: floor.y - S.player.height });
                S.showcaseCharacters.push({ type: 'PENGUIN', x: 180, y: floor.y - S.player.height });
                S.showcaseCharacters.push({ type: 'ESKIMO_FEMALE', x: 240, y: floor.y - S.player.height });
            } else { // Stage 102
                S.platforms.push({ x: 0, y: canvas.height - 40 - C.VERTICAL_GAP, width: canvas.width, height: C.PLATFORM_HEIGHT });
                S.platforms.push({ x: 0, y: canvas.height - 40 - (C.VERTICAL_GAP * 2), width: canvas.width, height: C.PLATFORM_HEIGHT });
            }
            S.goalPlatform = { x: -200, y: -200, width: 0, height: 0, type: 'goal' }; 
            S.platforms.push(S.goalPlatform);
            Game.Enemies.generateEnemies(); 
            Game.Level.generateDecorations();
            return;
        }

        S.platforms = [];
        let basePlatform;
        if (basePlatformsArg && basePlatformsArg.length > 0) {
            const minX = Math.min(...basePlatformsArg.map(p => p.x));
            const maxX = Math.max(...basePlatformsArg.map(p => p.x + p.width));
            basePlatform = { x: minX, y: S.canvas.height - 20, width: maxX - minX, height: C.PLATFORM_HEIGHT, type: 'base', subType: 'normal' };
        } else {
            basePlatform = { x: 0, y: S.canvas.height - 20, width: S.canvas.width, height: C.PLATFORM_HEIGHT, type: 'base', subType: 'normal' };
        }

        basePlatform.x -= 30;
        basePlatform.width += 60;
        S.platforms.push(basePlatform);

        let currentY = basePlatform.y;
        while (currentY > C.VERTICAL_GAP + 80) { 
            const newY = currentY - C.VERTICAL_GAP;
            const isFirst = (newY === basePlatform.y - C.VERTICAL_GAP);
            const newLayout = this.generatePlatformRow(isFirst);
            const newPlatforms = this.parseLayoutToPlatforms(newLayout, newY);

            if (newPlatforms.length > 0) {
                newPlatforms[0].x -= 30;
                newPlatforms[0].width += 30;
                newPlatforms[newPlatforms.length - 1].width += 30;
            }

            S.platforms.push(...newPlatforms);
            currentY = newY;
        }

        const topPlatformY = 0 - C.PLATFORM_HEIGHT / 2;
        const topLayout = Array(C.LEVEL_SLOTS).fill('G');
        const startPos = 3 + Math.floor(Math.random() * 3);
        for (let j = 0; j < 3; j++) topLayout[startPos + j] = 'B';
        const goalPlatforms = this.parseLayoutToPlatforms(topLayout, topPlatformY, 'top');
        if (goalPlatforms.length > 0) {
            S.goalPlatform = goalPlatforms.find(p => p.type === 'top') || goalPlatforms[0];
        } else {
            S.goalPlatform = {x: 150, y: topPlatformY, width: 120, height: C.PLATFORM_HEIGHT, type: 'top'};
            goalPlatforms.push(S.goalPlatform);
        }

        if (goalPlatforms.length > 0) {
            goalPlatforms[0].x -= 30;
            goalPlatforms[0].width += 30;
            goalPlatforms[goalPlatforms.length - 1].width += 30;
        }
        S.platforms.push(...goalPlatforms);

        Game.Enemies.generateEnemies();
        Game.Level.generateDecorations();
    },

    generatePowerUps: function() {
        const S = Game.State;
        S.powerUps = [];
        const spawnablePlatforms = S.platforms.filter(p => p.type === 'normal' && p.y < S.canvas.height - 100 && p.y > 100 && (p.subType === 'normal' || p.subType === 'icy'));
        if (spawnablePlatforms.length < 1) return;

        let availablePowerUps = ['HAMMER', 'SHIELD'];

        if (S.player.powerUp) {
            availablePowerUps = availablePowerUps.filter(type => type !== S.player.powerUp.type);
        }

        if (availablePowerUps.length === 0) return;

        const platform = spawnablePlatforms[Math.floor(Math.random() * spawnablePlatforms.length)];
        const powerUpType = availablePowerUps[Math.floor(Math.random() * availablePowerUps.length)];

        S.powerUps.push({
            type: powerUpType,
            x: platform.x + platform.width / 2 - 12.5,
            y: platform.y - 25,
            width: 25,
            height: 25
        });
    },

    generateDecorations: function() {
        const S = Game.State;
        S.decorations = [];
        const verticalGapShowcase = 130;
        const levelYShowcase = {
            aras2: S.canvas.height - 40 - verticalGapShowcase,
            aras3: S.canvas.height - 40 - (verticalGapShowcase * 2),
            aras4: S.canvas.height - 40 - (verticalGapShowcase * 3)
        };

        if (S.stage === 101) {
            S.platforms.forEach(p => {
                if (p.y === levelYShowcase.aras2) {
                    S.decorations.push({ type: 'ICY_GRASS', x: p.x + 20, y: p.y });
                    S.decorations.push({ type: 'SNOW_PILE', x: p.x + 70, y: p.y });
                } else if (p.y === levelYShowcase.aras3) {
                    S.decorations.push({ type: 'FROZEN_PUDDLE', x: p.x + 40, y: p.y });
                    S.decorations.push({ type: 'ICE_ROCK', x: p.x + 90, y: p.y });
                } else if (p.y === levelYShowcase.aras4) {
                    S.decorations.push({ type: 'SNOWY_TREE', x: p.x + 50, y: p.y });
                    S.decorations.push({ type: 'SIGNPOST', x: p.x + 20, y: p.y });
                }
            });
            return;
        }
        if (S.stage === 102) return;

        if (S.stage > 1 && S.stage % 10 === 1) {
            const startPlatform = S.platforms[0];
            const flagX = startPlatform.x + (startPlatform.width / 2) + (S.player.width);
            const flagY = startPlatform.y;
            S.decorations.push({ type: 'CHECKPOINT_FLAG', x: flagX, y: flagY });
        }

        S.platforms.forEach(p => {
            if (p !== S.platforms[0] && p !== S.goalPlatform) {
                if (p.subType !== 'normal' && p.subType !== 'icy') {
                    return;
                }
                for(let i=0; i < 3; i++) { 
                    if (Math.random() < S.decorationProbability) {
                        const sizeRoll = Math.random();
                        const decor = { type: '', x: p.x + Math.random() * (p.width - 40) + 20, y: p.y };

                        if (sizeRoll < 0.2) { decor.type = 'SNOWY_TREE'; } 
                        else if (sizeRoll < 0.5) {
                            const mediumTypeRoll = Math.random();
                            if (mediumTypeRoll < 0.33) decor.type = 'FROZEN_PUDDLE';
                            else if (mediumTypeRoll < 0.66) decor.type = 'ICE_ROCK';
                            else decor.type = 'SIGNPOST';
                        } else {
                            const smallTypeRoll = Math.random();
                            if (smallTypeRoll < 0.33) decor.type = 'SNOW_PILE';
                            else if (smallTypeRoll < 0.66) decor.type = 'ICE_SHARD';
                            else decor.type = 'ICY_GRASS';
                        }

                        if (decor.type) S.decorations.push(decor);
                    }
                }
            }
        });
    }
});

	Object.assign(Game.Graphics, {
    updateHpDisplay: function() {
        const S = Game.State;
        if (S.debugModeActive) {
            S.hpDisplay.innerHTML = `HP: ${S.player.hp}`;
            return;
        }
        let hearts = '';
        for (let i = 0; i < S.player.hp; i++) {
            hearts += '❤️';
        }
        S.hpDisplay.innerHTML = hearts;
    },

    draw: function() {
        const S = Game.State;
        S.ctx.clearRect(0, 0, S.canvas.width, S.canvas.height);
        this.drawBackground();
        S.platforms.forEach(p => {
            const ctx = S.ctx;
            let shakeX = 0;
            if (p === S.crumblingPlatformCandidate && !p.isFalling) {
                shakeX = Math.sin(S.globalAnimationTick * 0.8) * 1.5;
            }
            switch (p.subType) {
                case 'icy': ctx.fillStyle = '#A8D8F0'; break;
                case 'moving': ctx.fillStyle = '#B2B2B2'; break;
                case 'crumbling':
                    ctx.fillStyle = '#E0E0E0';
                    ctx.fillRect(p.x + shakeX, p.y, p.width, p.height);
                    return;
                default:
                    if (p.type === 'base') ctx.fillStyle = '#CCCCCC';
                    else if (p.type === 'top' || p === S.goalPlatform) ctx.fillStyle = '#FFD700';
                    else ctx.fillStyle = '#FFFFFF';
            }
            ctx.fillRect(p.x, p.y, p.width, p.height);
        });
        this.drawEntities(S.decorations, true);
        this.drawPowerUps();
        this.drawEntities(S.projectiles, true);
        this.drawEntities(S.enemies);
        this.drawPlayer();
        this.drawEntities(S.showcaseCharacters, true);
    },

    drawEntities: function(entities, isStatic = false) {
        const S = Game.State;
        entities.forEach(entity => {
            const config = Game.Assets[entity.type];
            if (config) {
                this.drawAsset(S.ctx, config, entity, isStatic);
            }
        });
    },

    drawPlayer: function() {
        const S = Game.State;
        if (S.stage !== 101) {
            const config = Game.Assets[S.selectedCharacter];
            if (config) this.drawAsset(S.ctx, config, S.player);
        }
    },

    drawCharacterPreviews: function() {
        const G = Game.Graphics;
        const characterData = { width: 30, height: 30, onGround: true, dx: 0 };
        const previewChars = ['ESKIMO', 'PENGUIN', 'ESKIMO_FEMALE', 'TERMINATOR'];
        previewChars.forEach(charType => {
            const canvasId = `${charType.toLowerCase().replace('_', '-')}-preview`;
            const canvas = document.getElementById(canvasId);
            const config = Game.Assets[charType];
            if (canvas && config) {
                const pCtx = canvas.getContext('2d');
                pCtx.clearRect(0, 0, 60, 60);
                const scale = 60 / (config.size || 100);
                const xPos = (60 - (config.size * scale)) / 2;
                const yPos = (60 - (config.size * scale)) / 2;
                G.drawAsset(pCtx, config, { ...characterData, x: xPos, y: yPos, isCrouching: false }, true, scale);
            }
        });
    },

    drawBackground: function() {
        const S = Game.State, ctx = S.ctx, canvas = S.canvas;
        const stage = S.stage;
        let skyColor0 = '#0c1445', skyColor1 = '#346888';
        let mount1Color = '#1e2d40', mount2Color = '#15202e', mount3Color = '#0d1520';
        if (stage >= 11 && stage <= 20) { skyColor0 = '#1c1445'; skyColor1 = '#433488'; mount1Color = '#2d1e40'; mount2Color = '#20152e'; mount3Color = '#150d20'; }
        else if (stage >= 21 && stage <= 30) { skyColor0 = '#607D8B'; skyColor1 = '#B0BEC5'; mount1Color = '#78909C'; mount2Color = '#546E7A'; mount3Color = '#37474F'; }
        else if (stage > 30) { skyColor0 = '#023047'; skyColor1 = '#0288D1'; mount1Color = '#01579B'; mount2Color = '#014073'; mount3Color = '#002340'; }
        const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
        sky.addColorStop(0, skyColor0); sky.addColorStop(1, skyColor1);
        ctx.fillStyle = sky; ctx.fillRect(0, 0, canvas.width, canvas.height);
        if(stage >= 20 || [101, 102].includes(stage)) { ctx.fillStyle = '#f0f0d0'; ctx.beginPath(); ctx.arc(320, 100, 30, 0, Math.PI * 2); ctx.fill(); }
        const m_y = { m1: [[250, 450], [150, 350], [220, 420], [120, 320], [250, 450], [200, 400]], m2: [[300, 500], [250, 450], [320, 520], [260, 460], [300, 500], [280, 480]], m3: [[400, 600], [380, 580], [410, 610], [370, 570], [420, 620], [390, 590]] }; 
        function lerp(start, end, amt) { return (1 - amt) * start + amt * end; } 
        const progressFactor = ([101, 102].includes(stage)) ? 1 : Math.min(1, (stage - 1) / 89);
        function drawMount(color, points, y_data) { ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(0, canvas.height); points.forEach((p, i) => ctx.lineTo(p, lerp(y_data[i][0], y_data[i][1], progressFactor))); ctx.lineTo(canvas.width, canvas.height); ctx.closePath(); ctx.fill(); } 
        drawMount(mount1Color, [0, 80, 150, 220, 300, canvas.width], m_y.m1); 
        drawMount(mount2Color, [50, 120, 200, 280, 350, canvas.width], m_y.m2); 
        drawMount(mount3Color, [30, 100, 180, 260, 330, canvas.width], m_y.m3);
    },

    drawPowerUps: function() {
        const S = Game.State;
        S.powerUps.forEach(p => {
            const config = Game.Assets[p.type];
            if (config) {
                const tick = S.globalAnimationTick;
                const glowRadius = p.width / 2 + 5 + Math.sin(tick * 0.1) * 3;
                const glowOpacity = 0.4 + Math.sin(tick * 0.1) * 0.2;
                S.ctx.save();
                S.ctx.fillStyle = `rgba(255, 255, 150, ${glowOpacity})`;
                S.ctx.beginPath();
                S.ctx.arc(p.x + p.width / 2, p.y + p.height / 2, glowRadius, 0, Math.PI * 2);
                S.ctx.fill();
                S.ctx.restore();
                this.drawAsset(S.ctx, config, p, true);
            }
        });
    },

    drawAsset: function(ctx, config, entity, isStatic = false, customScale = 1, isHeldItem = false, isAttackingItem = false) {
        if (entity.isHit && Math.floor(Game.State.globalAnimationTick / 4) % 2 === 0) return;

        ctx.save();
        if (!isHeldItem && !isAttackingItem) {
            ctx.translate(entity.x, entity.y);
        }

        const tick = Game.State.globalAnimationTick;
        const animState = {
            tick: tick,
            isCrouching: entity.isCrouching,
            isMoving: !isStatic && entity.onGround && entity.dx !== 0,
            isAttacking: entity.isAttacking,
            facing: entity.facing,
            state: entity.state,
            hits: entity.hits
        };

        const drawOrder = isHeldItem || isAttackingItem ? config.drawOrder : config.drawOrder;

        drawOrder.forEach(partName => {
            const part = config.parts[partName];
            if (part) {
                this.drawPart(ctx, part, entity, animState, customScale, isHeldItem, isAttackingItem);
            }
        });

        if (entity.isBlocking) {
            const shieldConfig = Game.Assets['SHIELD_SIDE'];
            const shieldEntity = {
                x: (entity.direction === 'right' ? entity.width - 4 : 0),
                y: 2
            };
            if(shieldConfig) this.drawAsset(ctx, shieldConfig, shieldEntity, true);
        } else if (entity.isAttacking) {
            const hammerConfig = Game.Assets['HAMMER'];
            if(hammerConfig) this.drawAsset(ctx, hammerConfig, entity, false, 1, false, true);
        }
        ctx.restore();
    },
    drawPart: function(ctx, part, entity, animState, scale = 1, isHeldItem = false, isAttackingItem = false) {
        if (part.condition && !part.condition(animState)) {
            return;
        }
        ctx.save();
        ctx.fillStyle = part.color;

        let animX = 0, animY = 0, animRot = 0;
        if (part.animation) {
            const anim = part.animation;
            let doAnimate = true;
            if (anim.condition && !anim.condition(animState)) {
               doAnimate = false;
            }
            if(doAnimate) {
                const animValue = Math.sin(animState.tick * anim.speed) * anim.amplitude;
                switch (anim.property) {
                    case 'rotation': animRot = animValue; break;
                    case 'y': animY = animValue * scale; break;
                    case 'x': animX = animValue * scale; break;
                }
            }
        }

        let partX = (part.x || 0) * scale + animX;
        let partY = (part.y || 0) * scale + animY;

        if (isHeldItem) {
            ctx.translate(entity.width/2, entity.height/2 - 5);
            ctx.rotate(entity.direction === 'right' ? -Math.PI / 6 : Math.PI / 6);
            partX -= 12.5 * scale; partY -= 15 * scale;
        }
        if (isAttackingItem) {
            const armY = 15 * scale;
            const pivotX = entity.direction === 'right' ? entity.width - 2 : 2;
            const pivotY = armY;
            ctx.translate(pivotX, pivotY);
            const swingProgress = (30 - entity.attackTimer) / 30;
            const swingAngle = Math.sin(swingProgress * Math.PI) * (Math.PI / 1.5);
            ctx.rotate(entity.direction === 'right' ? swingAngle : -swingAngle);
            partX -= 12.5 * scale; partY -= 25 * scale;
        }

        ctx.translate(partX, partY);
        if (animRot !== 0) {
            const pivotX = (part.pivot ? part.pivot.x : 0) * scale;
            const pivotY = (part.pivot ? part.pivot.y : 0) * scale;
            ctx.translate(pivotX, pivotY);
            ctx.rotate(animRot);
            ctx.translate(-pivotX, -pivotY);
        }

        ctx.beginPath();
        switch (part.shape) {
            case 'rect': ctx.rect(0, 0, part.width * scale, part.height * scale); break;
            case 'ellipse': ctx.ellipse( (part.width/2) * scale, (part.height/2) * scale, (part.width/2) * scale, (part.height/2) * scale, 0, 0, Math.PI * 2); break;
            case 'arc': ctx.arc(part.cx * scale, part.cy * scale, part.radius * scale, part.startAngle, part.endAngle); break;
            case 'path':
                ctx.moveTo(part.points[0][0] * scale, part.points[0][1] * scale);
                for(let i=1; i<part.points.length; i++){
                    ctx.lineTo(part.points[i][0] * scale, part.points[i][1] * scale);
                }
                ctx.closePath();
                break;
            case 'line':
                ctx.strokeStyle = part.color;
                ctx.lineWidth = part.lineWidth || 1;
                ctx.moveTo(part.startX * scale, part.startY * scale);
                ctx.lineTo(part.endX * scale, part.endY * scale);
                ctx.stroke();
                ctx.restore();
                return;
        }
        ctx.fill();
        ctx.restore();
    }
});

	Object.assign(Game.Controls, {
    keys: { left: false, right: false, up: false, down: false, a: false, b: false },
    setupEventListeners: function() {
        const S = Game.State;
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (S.debugCodeMenu.style.display === 'flex' || S.nameInputMenu.style.display === 'flex' || S.gameOver) return;
            if (key === 'arrowleft') this.keys.left = true;
            if (key === 'arrowright') this.keys.right = true;
            if (key === 'arrowdown') this.keys.down = true;
            if (key === 'arrowup' || key === 'd') { e.preventDefault(); this.keys.up = true; this.keys.a = true; }
            if (key === 's') { e.preventDefault(); this.keys.b = true; }
            if (e.ctrlKey && key === 'd') {
                e.preventDefault();
                S.debugCodeMenu.style.display = 'flex';
                S.debugCodeInput.focus();
            }
        });
        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'arrowleft') this.keys.left = false;
            if (key === 'arrowright') this.keys.right = false;
            if (key === 'arrowdown') this.keys.down = false;
            if (key === 'arrowup' || key === 'd') { this.keys.up = false; this.keys.a = false; }
            if (key === 's') { this.keys.b = false; }
        });
        const checkDebugCode = () => {
            try {
                if (atob(S.secretCode) === S.debugCodeInput.value) {
                    S.debugModeActive = !S.debugModeActive;
                    S.mainContainer.classList.toggle('show-debug', S.debugModeActive);
                    S.player.maxHp = S.debugModeActive ? 99 : (S.player.powerUp ? 2 : 1);
                    S.player.hp = S.player.maxHp;
                    if (!S.debugModeActive) S.landedYLevels.clear();
                }
            } catch (err) {}
            S.debugCodeInput.value = '';
            S.debugCodeMenu.style.display = 'none';
            Object.keys(this.keys).forEach(k => this.keys[k] = false);
        };
        S.debugCodeSubmit.addEventListener('click', checkDebugCode);
        S.debugCodeInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') checkDebugCode();
            else if (e.key === 'Escape') { S.debugCodeInput.value = ''; S.debugCodeMenu.style.display = 'none'; Object.keys(this.keys).forEach(k => this.keys[k] = false); }
        });
        S.nameInputSubmit.addEventListener('click', async () => {
            const S = Game.State;
            let playerName = S.nameInputField.value.trim();
            if (playerName && playerName.length > 0) {
                playerName = playerName.substring(0, 8).toUpperCase();
                localStorage.setItem('iceClimberPlayerName', playerName);
                S.playerName = playerName;
                await Game.Firebase.saveHighScore(S.score, S.playerName, S.stage);
                await Game.Firebase.loadHighScores();
                S.nameInputMenu.style.display = 'none';
            }
        });
        S.nameInputField.addEventListener('keydown', (e) => { if(e.key === 'Enter') S.nameInputSubmit.click()});

        S.instructionsButton.addEventListener('click', () => { S.startMenu.style.display = 'none'; S.instructionsMenu.style.display = 'flex'; });
        S.backToStartMenuButton.addEventListener('click', () => { S.instructionsMenu.style.display = 'none'; S.startMenu.style.display = 'flex'; });
        S.startButton.addEventListener('click', Game.Core.startGame);
        S.continueButton.addEventListener('click', () => { Game.Core.startGame(); });
        S.restartButton.addEventListener('click', () => { S.checkpointStage = 1; S.stage = 1; S.gameOverMenu.style.display = 'none'; S.startMenu.style.display = 'flex'; if (isMobile) { document.getElementById('on-screen-controls').style.display = 'none'; } Game.Core.resetGame(); Game.Graphics.draw(); });
        S.decorationSlider.addEventListener('input', (e) => { const v = parseInt(e.target.value, 10); S.decorationProbability = v / 100; S.decorationValue.textContent = `${v}%`; });
        S.enemySelectionButtons.forEach(b => { b.addEventListener('click', () => { S.enemySelectionButtons.forEach(btn => btn.classList.remove('selected')); b.classList.add('selected'); S.testEnemyType = b.dataset.enemy; if (S.stage === 102) { Game.Enemies.generateEnemies(); Game.Graphics.draw(); } }); });
        S.characterSelectors.forEach(s => { s.addEventListener('click', () => { S.characterSelectors.forEach(sel => sel.classList.remove('selected')); s.classList.add('selected'); S.selectedCharacter = s.dataset.char; }); });
        S.stagePresetButtons.forEach(b => { b.addEventListener('click', (e) => {
            const newStage = parseInt(e.target.dataset.stage, 10); if (isNaN(newStage)) return;
            S.stage = newStage; S.checkpointStage = S.stage;
            S.stageDisplay.textContent = S.stage; S.gameOver = false; S.isTransitioning = false; S.score = 0; S.scoreDisplay.textContent = S.score; S.landedYLevels = new Set();
            if (newStage > 1 && ![101,102].includes(newStage)) {
                const baseW = S.player.width * 3;
                const base = [{ x: (S.canvas.width/2)-(baseW/2), width: baseW, type: 'top' }];
                Game.Level.generatePlatforms(base);
            } else {
                Game.Level.generatePlatforms();
            }
            const startP = S.platforms[0]; S.player.y = startP.y - S.player.height; S.player.x = ([101,102].includes(S.stage)) ? 20 : startP.x + (startP.width / 2) - (S.player.width / 2); S.player.dx = 0; S.player.dy = 0; S.player.onGround = true;
            if (S.startMenu.style.display !== 'none' || S.gameOverMenu.style.display !== 'none') { Game.Graphics.draw(); } else { if (Game.Core.animationFrameId) cancelAnimationFrame(Game.Core.animationFrameId); Game.Core.gameLoop(); }
        }); });
        S.resetPlatformsButton.addEventListener('click', () => {
            if ([101, 102].includes(S.stage)) return;
            Game.Level.generatePlatforms(null);
            Game.Level.generatePowerUps();
            const startP = S.platforms[0]; S.player.y = startP.y - S.player.height; S.player.x = startP.x + (startP.width / 2) - (S.player.width / 2); S.player.dx = 0; S.player.dy = 0; S.player.onGround = true; Game.Graphics.draw();
        });
        S.refreshHighscoreBtn.addEventListener('click', () => Game.Firebase.loadHighScores());
        const btnLeft = document.getElementById('btn-left'); const btnRight = document.getElementById('btn-right'); const btnUp = document.getElementById('btn-up'); const btnDown = document.getElementById('btn-down'); const btnA = document.getElementById('btn-a'); const btnB = document.getElementById('btn-b');
        const handleTouch = (element, key, isPressed) => {
            element.addEventListener(isPressed ? 'touchstart' : 'touchend', (e) => {
                e.preventDefault();
                this.keys[key] = isPressed;
                if (key === 'a') this.keys['up'] = isPressed;
                element.classList.toggle('pressed', isPressed);
            }, { passive: false });
        };
        handleTouch(btnLeft, 'left', true); handleTouch(btnLeft, 'left', false);
        handleTouch(btnRight, 'right', true); handleTouch(btnRight, 'right', false);
        handleTouch(btnDown, 'down', true); handleTouch(btnDown, 'down', false);
        handleTouch(btnUp, 'up', true); handleTouch(btnUp, 'up', false);
        handleTouch(btnA, 'a', true); handleTouch(btnA, 'a', false);
        handleTouch(btnB, 'b', true); handleTouch(btnB, 'b', false);
    }
});
Object.assign(Game.Debug, {
    updateDebugInfo: function() {
        const S = Game.State;
        if (!S.debugModeActive) return;
        S.debugPlayerX.textContent = S.player.x.toFixed(2); S.debugPlayerY.textContent = S.player.y.toFixed(2);
        S.debugPlayerDX.textContent = S.player.dx.toFixed(2); S.debugPlayerDY.textContent = S.player.dy.toFixed(2);
        S.debugPlayerOnGround.textContent = S.player.onGround;
        S.debugCollision.textContent = S.player.isHit ? 'YA' : 'Tidak';
    }
});
Object.assign(Game.Firebase, {
    db: null, auth: null,
    init: function() {
        try {
            const firebaseConfig = {
                apiKey: "AIzaSyBDuQgpyrVT-hOYucH51AATLxDRLaKWgpQ",
                authDomain: "retro-game-6d9c7.firebaseapp.com",
                projectId: "retro-game-6d9c7",
                storageBucket: "retro-game-6d9c7.appspot.com",
                messagingSenderId: "258289584699",
                appId: "1:258289584699:web:d9228a2a2e3cbc0b41aa1e",
                measurementId: "G-G16BRQJB7D"
            };
            const app = initializeApp(firebaseConfig);
            this.db = getFirestore(app);
            this.auth = getAuth(app);
            onAuthStateChanged(this.auth, user => {
                if (user) {
                    Game.State.userId = user.uid;
                    if(!Game.State.firebaseReady) {
                        Game.State.firebaseReady = true;
                        this.loadHighScores(); 
                    }
                }
            });
            signInAnonymously(this.auth);
        } catch (error) {
            console.error("Firebase Init Error:", error);
        }
    },
    handleNewHighScore: async function() {
        const S = Game.State;
        if (!S.firebaseReady) {
            setTimeout(() => Game.Firebase.handleNewHighScore(), 200);
            return;
        }
        const scoreRef = doc(this.db, "games", "ice-climber", "highscores", S.userId);
        try {
            const docSnap = await getDoc(scoreRef);
            const currentHighScore = docSnap.exists() ? docSnap.data().score : 0;
            if (S.score > currentHighScore) {
                S.nameInputMenu.style.display = 'flex';
                S.nameInputField.value = localStorage.getItem('iceClimberPlayerName') || '';
                S.nameInputField.focus();
            } else {
                 await this.loadHighScores();
            }
        } catch(e) { console.error("Error checking high score:", e); await this.loadHighScores(); }
    },
    saveHighScore: async function(score, name, stage) {
        const S = Game.State;
        if (!S.userId) return;
        const scoreRef = doc(this.db, "games", "ice-climber", "highscores", S.userId);
        try {
            await setDoc(scoreRef, { score: score, name: name, stage: stage });
        } catch (error) { console.error("Error saving high score:", error); }
    },
    loadHighScores: async function() {
        if (!Game.State.firebaseReady) {
             setTimeout(() => this.loadHighScores(), 200);
             return;
        }
        const highscoreList = document.getElementById('highscore-list');
        const startHighscoreDisplay = document.getElementById('start-highscore-display');
        highscoreList.innerHTML = '<h4>Loading...</h4>';
        startHighscoreDisplay.innerHTML = '<p>Loading...</p>';
        try {
            const q = query(collection(this.db, "games", "ice-climber", "highscores"), orderBy("score", "desc"));
            const querySnapshot = await getDocs(q);
            let scoresHTML = '';
            let count = 0;
            const medals = ['🥇', '🥈', '🥉', '4.', '5.'];
            querySnapshot.forEach((doc) => {
                if(count < 5) {
                    const data = doc.data();
                    const medal = medals[count] || `${count + 1}.`;
                    const name = data.name.padEnd(8, ' ');
                    const stageText = `P${data.stage}`.padEnd(5, ' ');
                    scoresHTML += `<p>${medal} ${name} ${stageText} ${data.score}</p>`;
                    count++;
                }
            });
             if(count === 0) {
                 scoresHTML = '<p>No scores yet!</p>';
             }
            highscoreList.innerHTML = '<h4>HIGH SCORES</h4>' + scoresHTML;
            startHighscoreDisplay.innerHTML = scoresHTML;
        } catch (error) {
            console.error("Error loading high scores:", error);
            const errorMsg = '<h4>Error loading scores</h4>';
            highscoreList.innerHTML = errorMsg;
            startHighscoreDisplay.innerHTML = errorMsg;
        }
    }
});

Game.Core.init();
    </script>
</body>
</html>
