<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Snake Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Basic styling for the game page */
        body {
            background-color: #1a1a1a;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
            color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
        }

        /* Main game container */
        .game-container {
            text-align: center;
            border: 4px solid #555;
            border-radius: 15px;
            padding: 20px;
            background-color: #2b2b2b;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        h1 {
            font-size: 2rem;
            color: #00ff00;
            text-shadow: 2px 2px #000;
        }

        /* Score & Stage display */
        #game-info-container {
            font-size: 1.2rem;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-around;
            width: 100%;
        }

        .info-box span {
            color: #ffff00;
        }
        
        #bonus-stage-title {
            color: #ff00ff;
            font-size: 1.5rem;
            text-shadow: 2px 2px #000;
            margin-bottom: 15px;
        }

        /* The game board itself */
        #game-board {
            background-color: #0c0c0c;
            width: 400px;
            height: 400px;
            border: 2px solid #00ff00;
            position: relative;
            border-radius: 5px;
            margin: 0 auto;
            overflow: hidden; /* Keep flash effect contained */
            background-image:
                linear-gradient(rgba(0, 255, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 0, 0.1) 1px, transparent 1px);
        }
        
        /* D-pad Controls for Mobile */
        #dpad-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 150px;
            height: 150px;
            margin: 20px auto 0;
        }

        .dpad-button {
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid #555;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none; /* Prevent text selection */
        }

        .dpad-button:active {
            background-color: rgba(255, 255, 255, 0.3);
        }
        
        .dpad-button svg {
            width: 50%;
            height: 50%;
            fill: #00ff00;
        }
        
        #dpad-up    { grid-column: 2; grid-row: 1; border-top-left-radius: 10px; border-top-right-radius: 10px; }
        #dpad-left  { grid-column: 1; grid-row: 2; border-top-left-radius: 10px; border-bottom-left-radius: 10px; }
        #dpad-right { grid-column: 3; grid-row: 2; border-top-right-radius: 10px; border-bottom-right-radius: 10px; }
        #dpad-down  { grid-column: 2; grid-row: 3; border-bottom-left-radius: 10px; border-bottom-right-radius: 10px; }
        #dpad-center{ grid-column: 2; grid-row: 2; }

        /* Hide D-pad on larger screens */
        @media (min-width: 768px) {
            #dpad-controls {
                display: none;
            }
        }


        /* --- Stage Transition Effect --- */
        #transition-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: white;
            opacity: 0;
            z-index: 200;
            pointer-events: none;
            display: none;
        }

        @keyframes flash-effect {
            0% { opacity: 0; }
            50% { opacity: 0.8; }
            100% { opacity: 0; }
        }

        .flash {
            display: block !important;
            animation: flash-effect 0.5s ease-in-out;
        }

        /* --- New Snake Visual Styles (DIV-based) --- */
        .snake-segment {
            position: absolute;
            z-index: 2;
            box-sizing: border-box;
            transition: box-shadow 0.2s;
        }

        .snake-head {
            background-color: #33ff33;
            border-radius: 20%;
            position: relative;
        }

        .snake-head.boosting {
            box-shadow: 0 0 15px 5px #ffff00;
        }

        .snake-eye {
            position: absolute;
            background: white;
            border-radius: 50%;
            z-index: 3;
        }
        .snake-eye::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: black;
            border-radius: 50%;
            width: 60%;
            height: 60%;
        }

        .snake-body {
            background-color: #00ff00;
            border: 1px solid #000;
            border-radius: 15%;
            background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.2) 25%, transparent 25%, transparent 75%, rgba(255, 255, 255, 0.2) 75%),
                              linear-gradient(-45deg, rgba(255, 255, 255, 0.2) 25%, transparent 25%, transparent 75%, rgba(255, 255, 255, 0.2) 75%);
        }

        .snake-tail {
            background-color: #00dd00;
            border: 1px solid #000;
            border-radius: 15%;
        }

        /* Food & Maze styling */
        .game-object {
            position: absolute;
            text-align: center;
            z-index: 1;
            transition: transform 0.2s;
        }
        
        .maze-wall {
            position: absolute;
            background-color: #3030ff;
            box-shadow: inset 0 0 10px #00008b;
            border-radius: 15%;
            z-index: 0;
        }

        @keyframes spin-pulse {
            0% { transform: scale(1) rotate(0deg); text-shadow: 0 0 10px #fff, 0 0 20px #800080, 0 0 30px #800080; }
            50% { transform: scale(1.3) rotate(180deg); text-shadow: 0 0 15px #fff, 0 0 30px #ff00ff, 0 0 40px #ff00ff; }
            100% { transform: scale(1) rotate(360deg); text-shadow: 0 0 10px #fff, 0 0 20px #800080, 0 0 30px #800080; }
        }
        .portal {
            animation: spin-pulse 2s infinite linear;
        }
        
        /* --- General UI --- */
        .instructions-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-top: 20px;
        }

        p.instructions { margin: 0; font-size: 0.8rem; color: #aaa; }
        
        .debug-button {
            background-color: #555; color: #ffff00; border: 1px solid #ffff00;
            padding: 5px 10px; font-family: 'Press Start 2P', cursive;
            font-size: 0.6rem; border-radius: 5px; cursor: pointer;
        }
        
        #debug-panel {
            margin-top: 15px; padding: 10px; border: 2px dashed #ffff00;
            border-radius: 5px; font-size: 0.7rem; text-align: left; width: 380px;
        }
        #debug-panel h3 { margin: 0 0 10px 0; color: #ffff00; text-align: center; }
        #debug-panel p { margin: 5px 0; color: #ccc; }
        #debug-panel span { color: #00ff00; float: right; }

        .main-menu { display: flex; flex-direction: column; gap: 25px; align-items: center; }
        #speed-selection { padding: 10px 20px; min-width: 300px; }
        #speed-selection h2, #highscore-container h3, #game-over-scores h3 { margin-top: 0; margin-bottom: 25px; color: #ffff00; }
        .speed-control { display: flex; justify-content: center; align-items: center; margin-bottom: 25px; }
        #speed-display { font-size: 2.5rem; color: #00ff00; margin: 0 25px; width: 50px; text-align: center; }
        .speed-adjust-button {
            background: transparent; border: 2px solid #00ff00; color: #00ff00; font-size: 1.5rem;
            width: 40px; height: 40px; border-radius: 50%; cursor: pointer; transition: all 0.2s;
            display: flex; justify-content: center; align-items: center;
        }
        .speed-adjust-button:hover { background-color: #00ff00; color: #000; transform: scale(1.1); }
        #start-game-button {
            background-color: #00ff00; color: #000; border: none; padding: 10px 20px;
            font-family: 'Press Start 2P', cursive; font-size: 1rem; border-radius: 5px;
            cursor: pointer; transition: all 0.2s; width: 200px;
        }
        #start-game-button:hover { background-color: #ffff00; transform: scale(1.05); }

        #highscore-container { text-align: center; width: 100%; font-size: 0.7rem; }
        .highscore-columns-shared { display: flex; justify-content: center; gap: 40px; text-align: left; }
        .highscore-columns-shared ol { list-style-type: none; padding-left: 0; margin: 0; min-width: 170px; }
        .highscore-columns-shared li { margin-bottom: 8px; color: #f0f0f0; }
        .highscore-columns-shared li span { color: #ffff00; float: right; }

        .modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8); display: flex; justify-content: center;
            align-items: center; z-index: 100; border-radius: 10px;
        }
        .modal-content {
            color: #f0f0f0; background-color: #1a1a1a; padding: 30px; border-radius: 15px;
            border: 4px solid #555; text-align: center; box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            max-width: 450px;
        }
        .modal-content h2 { margin-top: 0; font-size: 1.8rem; }
        #new-highscore-entry { margin: 20px 0; }
        #player-name {
            background-color: #333; border: 2px solid #00ff00; color: #f0f0f0; padding: 8px;
            font-family: 'Press Start 2P', cursive; text-align: center; width: 150px; text-transform: uppercase;
        }
        .modal-content button {
            background-color: #00ff00; color: #000; border: none; padding: 10px 20px;
            font-family: 'Press Start 2P', cursive; font-size: 1rem; border-radius: 5px;
            cursor: pointer; margin-top: 15px; transition: all 0.2s;
        }
        .modal-content button:hover { background-color: #ffff00; transform: scale(1.05); }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>SNAKE</h1>
        <!-- Main Menu Screen -->
        <div class="main-menu" id="main-menu">
            <div id="speed-selection">
                <h2>SELECT SPEED</h2>
                <div class="speed-control">
                    <button id="speed-down-button" class="speed-adjust-button">-</button>
                    <span id="speed-display">3</span>
                    <button id="speed-up-button" class="speed-adjust-button">+</button>
                </div>
                <button id="start-game-button">Start Game</button>
            </div>
            <div id="highscore-container">
                <h3>HIGH SCORES</h3>
                <div id="highscore-columns-shared">
                    <ol id="highscore-list-1"></ol>
                    <ol id="highscore-list-2"></ol>
                </div>
            </div>
        </div>

        <!-- Game Area (hidden initially) -->
        <div id="game-area" style="display: none;">
            <div id="bonus-stage-title" style="display: none;">BONUS STAGE</div>
            <div id="game-info-container">
                <div class="info-box">Score: <span id="score-value">0</span></div>
                <div class="info-box">Stage: <span id="stage-value">1</span></div>
            </div>
            <div id="game-board">
                <div id="transition-overlay"></div>
            </div>
             <!-- D-pad Controls -->
            <div id="dpad-controls">
                <div id="dpad-up" class="dpad-button"><svg viewBox="0 0 24 24"><path d="M12 8l-6 6h12z"/></svg></div>
                <div id="dpad-left" class="dpad-button"><svg viewBox="0 0 24 24"><path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6z"/></svg></div>
                <div id="dpad-center"></div>
                <div id="dpad-right" class="dpad-button"><svg viewBox="0 0 24 24"><path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6z"/></svg></div>
                <div id="dpad-down" class="dpad-button"><svg viewBox="0 0 24 24"><path d="M12 16l6-6H6z"/></svg></div>
            </div>

            <div class="instructions-container">
                <p class="instructions">Use Arrow Keys to Move, Spacebar to Pause</p>
                <button id="debug-toggle-button" class="debug-button">Toggle Debug</button>
                <button id="reset-maze-button" class="debug-button" style="display: none;">Reset Maze</button>
            </div>
            <div id="debug-panel" style="display: none;">
                <h3>DEBUG INFO</h3>
                <div id="debug-normal-mode">
                    <p>Game Mode: <span id="debug-game-mode">N/A</span></p>
                    <p>Snake Length: <span id="debug-snake-length">N/A</span></p>
                    <p>Head (X,Y): <span id="debug-head-coords">N/A</span></p>
                </div>
                 <div id="debug-bonus-mode" style="display: none;">
                    <p>Game Mode: <span id="debug-game-mode-bonus">N/A</span></p>
                    <p>Walls: <span id="debug-walls">N/A</span></p>
                    <p>Foods: <span id="debug-foods">N/A</span></p>
                    <p>Start: <span id="debug-start">N/A</span></p>
                    <p>Exit: <span id="debug-exit">N/A</span></p>
                </div>
            </div>
        </div>
        
        <!-- Game Over Modal -->
        <div id="game-over-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <h2 style="color: #ff4136;">GAME OVER</h2>
                <p>Your Score: <span id="final-score">0</span></p>
                <div id="new-highscore-entry" style="display: none;">
                    <p>New High Score!</p>
                    <input type="text" id="player-name" maxlength="12" placeholder="ENTER NAME">
                    <button id="save-score-button">Save</button>
                </div>
                <div id="game-over-scores" style="display: none;">
                    <h3>HIGH SCORES</h3>
                    <div id="highscore-columns-gameover" class="highscore-columns-shared" style="font-size: 0.7rem;">
                        <ol id="gos-list-1"></ol> <ol id="gos-list-2"></ol>
                    </div>
                    <p style="margin-top: 20px; font-size: 0.9rem; color: #aaa;">TRY AGAIN!</p>
                </div>
                <button id="restart-button" style="display: none;">Play Again</button>
            </div>
        </div>
    </div>

    <script>
    // Version: v0.5.0

    /**
     * Manages all drawing operations on the game board.
     */
    class Board {
        constructor(boardElement, transitionElement) {
            this.boardElement = boardElement;
            this.transitionOverlay = transitionElement;
            this.dimension = 400; // Board pixel dimension
        }

        clear() {
            this.boardElement.innerHTML = '';
        }

        draw(state) {
            this.clear();
            const isBonus = state.gameMode === 'bonus';
            const gridSize = isBonus ? 20 : state.currentStageConfig.gridSize;
            const cellSize = this.dimension / gridSize;

            if (isBonus) {
                this._drawMaze(state.mazeObjects, cellSize);
            } else {
                this._drawFood(state.food, cellSize);
            }

            if (state.playerSnake) {
                state.playerSnake.draw(this.boardElement, cellSize, state.isBoosting, state.direction);
            }

            this.boardElement.appendChild(this.transitionOverlay);
        }

        _drawMaze(mazeObjects, cellSize) {
            mazeObjects.walls.forEach(wall => {
                const el = this._createGenericElement('div', 'maze-wall', wall, cellSize);
                this.boardElement.appendChild(el);
            });
            mazeObjects.foods.forEach(food => {
                const el = this._createGenericElement('div', 'game-object', food, cellSize);
                el.innerHTML = food.emoji;
                el.style.fontSize = `${cellSize * 0.9}px`;
                el.style.lineHeight = `${cellSize}px`;
                this.boardElement.appendChild(el);
            });
            const exitEl = this._createGenericElement('div', 'game-object portal', mazeObjects.exit, cellSize);
            exitEl.innerHTML = mazeObjects.exit.emoji;
            exitEl.style.fontSize = `${cellSize * 0.9}px`;
            exitEl.style.lineHeight = `${cellSize}px`;
            this.boardElement.appendChild(exitEl);
        }

        _drawFood(food, cellSize) {
            const el = this._createGenericElement('div', 'game-object', food, cellSize);
            if (food.isPortal) el.classList.add('portal');
            el.innerHTML = food.emoji;
            el.style.fontSize = `${cellSize * 0.9}px`;
            el.style.lineHeight = `${cellSize}px`;
            this.boardElement.appendChild(el);
        }

        _createGenericElement(tag, className, pos, cellSize) {
            const el = document.createElement(tag);
            el.className = className;
            el.style.left = `${pos.x * cellSize}px`;
            el.style.top = `${pos.y * cellSize}px`;
            el.style.width = `${cellSize}px`;
            el.style.height = `${cellSize}px`;
            return el;
        }

        flash() {
            this.transitionOverlay.classList.add('flash');
            setTimeout(() => {
                this.transitionOverlay.classList.remove('flash');
            }, 500);
        }
    }
    
    /**
     * Represents the snake in the game.
     */
    class Snake {
        constructor(x, y, length = 1) {
            this.body = Array.from({ length }, (_, i) => ({ x: x - i, y }));
        }

        getHead() { return this.body[0]; }
        move(nextHead) { this.body.unshift(nextHead); this.body.pop(); }
        grow(nextHead) { this.body.unshift(nextHead); }
        checkSelfCollision() {
            const head = this.getHead();
            return this.body.slice(1).some(segment => segment.x === head.x && segment.y === head.y);
        }
        
        draw(boardElement, cellSize, isBoosting, direction) {
            this.body.forEach((segment, index) => {
                const el = this._createSegmentElement(segment, cellSize);
                if (index === 0) this._drawHead(el, cellSize, isBoosting, direction);
                else if (index === this.body.length - 1 && this.body.length > 1) this._drawTail(el);
                else this._drawBody(el, cellSize);
                boardElement.appendChild(el);
            });
        }
        
        _createSegmentElement(segment, cellSize) {
            const el = document.createElement('div');
            el.className = 'snake-segment';
            el.style.left = `${segment.x * cellSize}px`;
            el.style.top = `${segment.y * cellSize}px`;
            el.style.width = `${cellSize}px`;
            el.style.height = `${cellSize}px`;
            return el;
        }

        _drawHead(element, cellSize, isBoosting, direction) {
            element.classList.add('snake-head');
            if (isBoosting) element.classList.add('boosting');
            const eye1 = document.createElement('div');
            eye1.className = 'snake-eye';
            const eye2 = document.createElement('div');
            eye2.className = 'snake-eye';
            eye1.style.width = eye1.style.height = eye2.style.width = eye2.style.height = `${Math.max(1, cellSize * 0.25)}px`;
            eye1.style.top = `${cellSize * 0.15}px`; eye1.style.right = `${cellSize * 0.2}px`;
            eye2.style.bottom = `${cellSize * 0.15}px`; eye2.style.right = `${cellSize * 0.2}px`;
            element.append(eye1, eye2);
            let headRotation = 0;
            if (direction) {
                switch (direction) {
                    case 'up':    headRotation = -90; break;
                    case 'down':  headRotation = 90; break;
                    case 'left':  headRotation = 180; break;
                    case 'right': headRotation = 0; break;
                }
                element.style.transform = `rotate(${headRotation}deg)`;
            }
        }

        _drawBody(element, cellSize) {
            element.classList.add('snake-body');
            element.style.backgroundSize = `${cellSize * 0.4}px ${cellSize * 0.4}px`;
        }

        _drawTail(element) { element.classList.add('snake-tail'); }
    }

    const mazeGenerator = {
        generate() {
            const width = 20, height = 20;
            const grid = Array.from({ length: height }, () => Array(width).fill('W'));
            const stack = [{ x: 0, y: 0 }];
            grid[0][0] = 'P';
            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = [];
                const directions = [{ x: 0, y: -2 }, { x: 0, y: 2 }, { x: -2, y: 0 }, { x: 2, y: 0 }];
                directions.sort(() => Math.random() - 0.5);
                for (const dir of directions) {
                    const nx = current.x + dir.x, ny = current.y + dir.y;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height && grid[ny][nx] === 'W') {
                        neighbors.push({ x: nx, y: ny });
                    }
                }
                if (neighbors.length > 0) {
                    const next = neighbors[0];
                    grid[current.y + (next.y - current.y) / 2][current.x + (next.x - current.x) / 2] = 'P';
                    grid[next.y][next.x] = 'P';
                    stack.push(next);
                } else {
                    stack.pop();
                }
            }
            const mazeObjects = { walls: [], foods: [], start: { x: 0, y: 0 }, exit: { x: 18, y: 18, emoji: '🌀', isPortal: true }};
            const paths = [];
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (grid[y][x] === 'W') mazeObjects.walls.push({ x, y });
                    else paths.push({ x, y });
                }
            }
            const foodPaths = paths.filter(p => !(p.x === 0 && p.y === 0) && !(p.x === 18 && p.y === 18));
            for (let i = 0; i < 25 && foodPaths.length > 0; i++) {
                const randIndex = Math.floor(Math.random() * foodPaths.length);
                mazeObjects.foods.push({ ...foodPaths.splice(randIndex, 1)[0], emoji: '🍎' });
            }
            return mazeObjects;
        }
    };

    /**
     * Main game controller class.
     */
    class Game {
        constructor() {
            this.config = {
                SPEED_MAP: { 1: 220, 2: 185, 3: 150, 4: 125, 5: 100, 6: 85, 7: 70, 8: 60, 9: 50 },
                STAGE_CONFIG: {
                    1: { gridSize: 10, targetCoverage: 0.05 }, 2: { gridSize: 16, targetCoverage: 0.05 },
                    3: { gridSize: 20, targetCoverage: 0.05 }, 4: { gridSize: 25, targetCoverage: 0.05 },
                    5: { gridSize: 40, targetCoverage: 0.05 },
                },
                BOOST_SPEED_MULTIPLIER: 2, BOOST_DURATION: 500, DOUBLE_TAP_THRESHOLD: 300,
            };

            this.state = {};
            this.ui = {};
            this.board = null;

            this._cacheDOMElements();
            this._bindEventListeners();

            this.board = new Board(this.ui.gameBoard, this.ui.transitionOverlay);
            
            this.loadHighScores();
            this.displayHighScores(this.ui.highscoreList1, this.ui.highscoreList2);
            this.ui.speedDisplay.textContent = 3; // Default speed
        }

        _cacheDOMElements() {
            this.ui = {
                gameBoard: document.getElementById('game-board'), transitionOverlay: document.getElementById('transition-overlay'),
                scoreValue: document.getElementById('score-value'), stageValue: document.getElementById('stage-value'),
                gameOverModal: document.getElementById('game-over-modal'), finalScore: document.getElementById('final-score'),
                restartButton: document.getElementById('restart-button'), mainMenu: document.getElementById('main-menu'),
                gameArea: document.getElementById('game-area'), speedDisplay: document.getElementById('speed-display'),
                startGameButton: document.getElementById('start-game-button'), newHighscoreEntry: document.getElementById('new-highscore-entry'),
                playerNameInput: document.getElementById('player-name'), saveScoreButton: document.getElementById('save-score-button'),
                speedUpButton: document.getElementById('speed-up-button'), speedDownButton: document.getElementById('speed-down-button'),
                highscoreList1: document.getElementById('highscore-list-1'), highscoreList2: document.getElementById('highscore-list-2'),
                gameOverScores: document.getElementById('game-over-scores'), gosList1: document.getElementById('gos-list-1'),
                gosList2: document.getElementById('gos-list-2'), pauseScreen: document.getElementById('pause-screen'),
                debugPanel: document.getElementById('debug-panel'), debugToggleButton: document.getElementById('debug-toggle-button'),
                resetMazeButton: document.getElementById('reset-maze-button'), debugNormalMode: document.getElementById('debug-normal-mode'),
                debugBonusMode: document.getElementById('debug-bonus-mode'), debugGameMode: document.getElementById('debug-game-mode'),
                debugSnakeLength: document.getElementById('debug-snake-length'), debugHeadCoords: document.getElementById('debug-head-coords'),
                debugGameModeBonus: document.getElementById('debug-game-mode-bonus'), debugWalls: document.getElementById('debug-walls'),
                debugFoods: document.getElementById('debug-foods'), debugStart: document.getElementById('debug-start'),
                debugExit: document.getElementById('debug-exit'), bonusStageTitle: document.getElementById('bonus-stage-title'),
                gameInfoContainer: document.getElementById('game-info-container'),
                dpadUp: document.getElementById('dpad-up'), dpadDown: document.getElementById('dpad-down'),
                dpadLeft: document.getElementById('dpad-left'), dpadRight: document.getElementById('dpad-right'),
            };
        }

        _bindEventListeners() {
            document.addEventListener('keydown', this.handleKeyDown.bind(this));
            this.ui.restartButton.addEventListener('click', this.returnToMainMenu.bind(this));
            this.ui.saveScoreButton.addEventListener('click', this.saveHighScore.bind(this));
            this.ui.playerNameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); this.saveHighScore(); } });
            this.ui.startGameButton.addEventListener('click', this.startGame.bind(this));
            this.ui.speedUpButton.addEventListener('click', () => this.changeSpeed(1));
            this.ui.speedDownButton.addEventListener('click', () => this.changeSpeed(-1));
            this.ui.debugToggleButton.addEventListener('click', () => {
                this.ui.debugPanel.style.display = this.ui.debugPanel.style.display === 'none' ? 'block' : 'none';
                this.updateDebugPanel();
            });
            this.ui.resetMazeButton.addEventListener('click', this.resetMaze.bind(this));
            // D-pad listeners
            this.ui.dpadUp.addEventListener('click', () => this._processInput('up'));
            this.ui.dpadDown.addEventListener('click', () => this._processInput('down'));
            this.ui.dpadLeft.addEventListener('click', () => this._processInput('left'));
            this.ui.dpadRight.addEventListener('click', () => this._processInput('right'));
        }

        startGame() {
            this.ui.mainMenu.style.display = 'none';
            this.ui.gameArea.style.display = 'block';
            this.ui.gameOverModal.style.display = 'none';

            if (this.state.gameInterval) clearInterval(this.state.gameInterval);

            this.state = {
                ...this.state, // Keep highscores and currentSpeed
                playerSnake: null, food: {}, direction: null, score: 0, gameOver: false,
                gameInterval: null, gameStarted: false, isPaused: false,
                inputQueue: [], currentStage: 1, currentStageConfig: {},
                gameMode: 'normal', mazeObjects: { walls: [], foods: [], exit: {} },
                bonusStageScore: 0, isBoosting: false, boostTimeout: null, lastKeyPressTime: 0,
                stage5FruitCount: 0, bonusStageEntries: 0,
            };
            this.state.gameSpeed = this.config.SPEED_MAP[this.state.currentSpeed];

            this.ui.scoreValue.textContent = this.state.score;
            this.ui.bonusStageTitle.style.display = 'none';
            this.ui.gameInfoContainer.style.display = 'flex';

            this.setupStage();
            this.generateFood();
            this.board.draw(this.state);
        }

        setupStage() {
            const stage = this.state.currentStage;
            const stageConfig = this.config.STAGE_CONFIG[stage];
            this.state.currentStageConfig = { ...stageConfig, targetLength: Math.floor(stageConfig.gridSize ** 2 * stageConfig.targetCoverage) };
            this.ui.stageValue.textContent = stage;
            const center = Math.floor(stageConfig.gridSize / 2);
            this.state.playerSnake = new Snake(center, center);
        }

        resetMaze() {
            if (this.state.gameMode !== 'bonus') return;
            this.state.mazeObjects = mazeGenerator.generate();
            this.state.playerSnake = new Snake(this.state.mazeObjects.start.x, this.state.mazeObjects.start.y);
            this.state.direction = null;
            this.state.bonusStageScore = 0;
            this.board.draw(this.state);
        }

        enterBonusStage() {
            if (this.state.boostTimeout) clearTimeout(this.state.boostTimeout);
            this.state.isBoosting = false;
            clearInterval(this.state.gameInterval);
            this.state.gameStarted = false;

            const setup = () => {
                this.state.gameMode = 'bonus';
                this.state.bonusStageScore = 0;
                this.resetMaze();
                this.state.currentStageConfig = { gridSize: 20 };
                this.ui.bonusStageTitle.style.display = 'block';
                this.ui.gameInfoContainer.style.display = 'none';
                this.state.inputQueue = [];
                this.state.direction = null;
            };

            this.board.flash();
            setTimeout(setup, 250);
        }

        exitBonusStage(isSuccess) {
            this.board.flash();
            setTimeout(() => {
                if (isSuccess) this.state.score += this.state.bonusStageScore * 10;
                else this.state.score += this.state.bonusStageScore;
                this.ui.scoreValue.textContent = this.state.score;

                if (this.state.currentStage < 5) this.state.currentStage++;
                else {
                    this.state.stage5FruitCount = 0;
                    this.state.bonusStageEntries++;
                }

                this.state.gameMode = 'normal';
                this.ui.bonusStageTitle.style.display = 'none';
                this.ui.gameInfoContainer.style.display = 'flex';
                this.setupStage();
                this.generateFood();
                this.board.draw(this.state);

                this.state.gameStarted = false;
                this.state.direction = null;
            }, 500);
        }
        
        returnToMainMenu() {
            if (this.state.gameInterval) clearInterval(this.state.gameInterval);
            this.ui.gameOverModal.style.display = 'none';
            this.ui.gameArea.style.display = 'none';
            this.ui.mainMenu.style.display = 'flex';
            this.ui.speedDisplay.textContent = this.state.currentSpeed;
            this.loadHighScores();
            this.displayHighScores(this.ui.highscoreList1, this.ui.highscoreList2);
        }

        mainLoop() {
            if (this.state.gameOver) {
                clearInterval(this.state.gameInterval);
                this.showGameOverScreen();
                return;
            }
            this.updateGameState();
            this.board.draw(this.state);
        }

        updateGameState() {
            while (this.state.inputQueue.length > 0) {
                const nextDirection = this.state.inputQueue.shift();
                if (!this.state.direction || (
                    (nextDirection === 'up' && this.state.direction !== 'down') ||
                    (nextDirection === 'down' && this.state.direction !== 'up') ||
                    (nextDirection === 'left' && this.state.direction !== 'right') ||
                    (nextDirection === 'right' && this.state.direction !== 'left')
                )) {
                    this.state.direction = nextDirection;
                    break;
                }
            }

            if (!this.state.direction) return;

            const head = { ...this.state.playerSnake.getHead() };
            switch (this.state.direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }

            if (this.state.gameMode === 'bonus') this.updateBonusMode(head);
            else this.updateNormalMode(head);
        }
        
        updateNormalMode(head) {
            if (this.hasHitWall(head) || this.state.playerSnake.checkSelfCollision(head)) {
                this.state.gameOver = true;
                return;
            }
            if (head.x === this.state.food.x && head.y === this.state.food.y) {
                this.state.playerSnake.grow(head);
                if (this.state.food.isPortal) {
                    if (this.state.currentStage < 5 || this.state.food.isSpecialBonus) {
                        this.enterBonusStage();
                        return;
                    }
                }
                this.state.score += this.state.currentSpeed;
                this.ui.scoreValue.textContent = this.state.score;
                if (this.state.currentStage === 5) this.state.stage5FruitCount++;
                this.generateFood();
            } else {
                this.state.playerSnake.move(head);
            }
        }

        updateBonusMode(head) {
            const gridSize = 20;
            const hitBoundary = head.x < 0 || head.x >= gridSize || head.y < 0 || head.y >= gridSize;
            const hitMazeWall = this.state.mazeObjects.walls.some(w => w.x === head.x && w.y === head.y);

            if (hitBoundary || hitMazeWall || this.state.playerSnake.checkSelfCollision(head)) {
                this.exitBonusStage(false);
                return;
            }
            const ateFoodIndex = this.state.mazeObjects.foods.findIndex(f => f.x === head.x && f.y === head.y);
            if (ateFoodIndex > -1) {
                this.state.mazeObjects.foods.splice(ateFoodIndex, 1);
                this.state.bonusStageScore += 10;
                this.state.playerSnake.grow(head);
            } else if (head.x === this.state.mazeObjects.exit.x && head.y === this.state.mazeObjects.exit.y) {
                this.exitBonusStage(true);
                return;
            } else {
                this.state.playerSnake.move(head);
            }
        }
        
        handleKeyDown(event) {
            const keyMap = { 'ArrowUp': 'up', 'ArrowDown': 'down', 'ArrowLeft': 'left', 'ArrowRight': 'right' };
            const newDirection = keyMap[event.key];

            if (event.key === ' ' || event.key === 'Spacebar') {
                event.preventDefault();
                this.togglePause();
                return;
            }
            if (newDirection) {
                event.preventDefault();
                this._processInput(newDirection);
            }
        }
        
        _processInput(newDirection) {
            if (this.state.isPaused || this.state.gameOver) return;
            const now = Date.now();
            if (this.state.gameMode === 'normal' && newDirection === this.state.direction && now - this.state.lastKeyPressTime < this.config.DOUBLE_TAP_THRESHOLD) {
                this.triggerBoost();
            }
            this.state.lastKeyPressTime = now;
            if (!this.state.gameStarted) {
                this.state.gameStarted = true;
                this.state.direction = newDirection;
                this.state.gameInterval = setInterval(() => this.mainLoop(), this.state.gameSpeed);
            } else if (this.state.inputQueue.length < 2) {
                this.state.inputQueue.push(newDirection);
            }
        }

        triggerBoost() {
            if (this.state.isBoosting) return;
            this.state.isBoosting = true;
            clearInterval(this.state.gameInterval);
            this.state.gameInterval = setInterval(() => this.mainLoop(), this.state.gameSpeed / this.config.BOOST_SPEED_MULTIPLIER);
            if (this.state.boostTimeout) clearTimeout(this.state.boostTimeout);
            this.state.boostTimeout = setTimeout(() => {
                this.state.isBoosting = false;
                if (!this.state.gameOver && !this.state.isPaused) {
                    clearInterval(this.state.gameInterval);
                    this.state.gameInterval = setInterval(() => this.mainLoop(), this.state.gameSpeed);
                }
            }, this.config.BOOST_DURATION);
        }

        generateFood() {
            const { gridSize } = this.state.currentStageConfig;
            let foodPos;
            const targetLength = this.state.currentStageConfig.targetLength || Infinity;
            let isPortal = this.state.playerSnake.body.length >= targetLength - 1;
            let isSpecialBonus = false;
            if (this.state.currentStage === 5) {
                const nextBonusThreshold = 10 + this.state.bonusStageEntries * 10;
                if (this.state.stage5FruitCount >= nextBonusThreshold - 1) {
                    isPortal = true;
                    isSpecialBonus = true;
                }
            }
            do {
                foodPos = { x: Math.floor(Math.random() * gridSize), y: Math.floor(Math.random() * gridSize) };
            } while (this.state.playerSnake.body.some(s => s.x === foodPos.x && s.y === foodPos.y));
            this.state.food = { ...foodPos, emoji: isPortal ? '🌀' : '🍎', isPortal, isSpecialBonus };
        }

        togglePause() {
            if (!this.state.gameStarted || this.state.gameOver) return;
            this.state.isPaused = !this.state.isPaused;
            if (this.state.isPaused) {
                clearTimeout(this.state.boostTimeout);
                this.state.isBoosting = false;
                clearInterval(this.state.gameInterval);
                this.ui.pauseScreen.style.display = 'flex';
            } else {
                this.state.gameInterval = setInterval(() => this.mainLoop(), this.state.gameSpeed);
                this.ui.pauseScreen.style.display = 'none';
            }
        }
        
        updateDebugPanel() {
            const isBonus = this.state.gameMode === 'bonus';
            this.ui.debugNormalMode.style.display = isBonus ? 'none' : 'block';
            this.ui.debugBonusMode.style.display = isBonus ? 'block' : 'none';
            this.ui.resetMazeButton.style.display = 'none';

            if (isBonus && this.ui.debugPanel.style.display === 'block') {
                this.ui.resetMazeButton.style.display = 'inline-block';
            }
            if (isBonus) {
                this.ui.debugGameModeBonus.textContent = this.state.gameMode;
                this.ui.debugWalls.textContent = this.state.mazeObjects.walls.length;
                this.ui.debugFoods.textContent = this.state.mazeObjects.foods.length;
                if (this.state.mazeObjects.start) this.ui.debugStart.textContent = `(${this.state.mazeObjects.start.x}, ${this.state.mazeObjects.start.y})`;
                if (this.state.mazeObjects.exit) this.ui.debugExit.textContent = `(${this.state.mazeObjects.exit.x}, ${this.state.mazeObjects.exit.y})`;
            } else if (this.state.playerSnake) {
                this.ui.debugGameMode.textContent = this.state.gameMode;
                this.ui.debugSnakeLength.textContent = this.state.playerSnake.body.length;
                const head = this.state.playerSnake.getHead();
                this.ui.debugHeadCoords.textContent = `${head.x}, ${head.y}`;
            }
        }
        
        hasHitWall(head) {
            const { gridSize } = this.state.currentStageConfig;
            return head.x < 0 || head.x >= gridSize || head.y < 0 || head.y >= gridSize;
        }

        changeSpeed(delta) {
            const currentSpeed = this.state.currentSpeed || 3;
            this.state.currentSpeed = Math.max(1, Math.min(9, currentSpeed + delta));
            this.ui.speedDisplay.textContent = this.state.currentSpeed;
            this.state.gameSpeed = this.config.SPEED_MAP[this.state.currentSpeed];
        }

        loadHighScores() {
            const scores = localStorage.getItem('snakeHighScores');
            this.state.highScores = scores ? JSON.parse(scores) : [];
        }

        displayHighScores(list1, list2) {
            list1.innerHTML = this.state.highScores.slice(0, 5).map((s, i) => `<li>${i + 1}. ${s.name} <span>${s.score}</span></li>`).join('');
            list2.innerHTML = this.state.highScores.slice(5, 10).map((s, i) => `<li>${i + 6}. ${s.name} <span>${s.score}</span></li>`).join('');
        }

        saveHighScore() {
            const playerName = this.ui.playerNameInput.value.trim().toUpperCase() || 'AAA';
            this.ui.playerNameInput.blur();
            this.state.highScores.push({ name: playerName, score: this.state.score });
            this.state.highScores.sort((a, b) => b.score - a.score);
            this.state.highScores = this.state.highScores.slice(0, 10);
            localStorage.setItem('snakeHighScores', JSON.stringify(this.state.highScores));
            this.ui.newHighscoreEntry.style.display = 'none';
            this.displayHighScores(this.ui.gosList1, this.ui.gosList2);
            this.ui.gameOverScores.style.display = 'block';
            this.ui.restartButton.style.display = 'block';
        }

        showGameOverScreen() {
            this.ui.finalScore.textContent = this.state.score;
            const { highScores, score } = this.state;
            const lowestHighScore = highScores.length < 10 ? 0 : highScores[highScores.length - 1].score;
            const isNewHighScore = score > 0 && (highScores.length < 10 || score >= lowestHighScore);

            if (isNewHighScore) {
                this.ui.newHighscoreEntry.style.display = 'block';
                this.ui.gameOverScores.style.display = 'none';
                setTimeout(() => this.ui.playerNameInput.focus(), 100);
                this.ui.restartButton.style.display = 'none';
            } else {
                this.ui.newHighscoreEntry.style.display = 'none';
                this.ui.restartButton.style.display = 'block';
                if (highScores.length > 0) {
                    this.ui.gameOverScores.style.display = 'block';
                    this.displayHighScores(this.ui.gosList1, this.ui.gosList2);
                } else {
                    this.ui.gameOverScores.style.display = 'none';
                }
            }
            this.ui.gameOverModal.style.display = 'flex';
        }
    }

    // Initialize the game once the DOM is fully loaded
    window.onload = () => {
        new Game();
    };
    </script>
</body>
</html>

